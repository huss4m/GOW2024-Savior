{"version":3,"file":"js/app.bb4e5436.js","mappings":"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","sources":["webpack://b101/./src/App.vue?49f4","webpack://b101/./src/App.vue","webpack://b101/./src/components/Savior.vue?97c8","webpack://b101/./src/components/Savior.vue","webpack://b101/./src/Savior/Enemy.ts","webpack://b101/./src/Savior/Mutant.ts","webpack://b101/./src/Savior/WeaponPickups.ts","webpack://b101/./src/Savior/AmmoPickup.ts","webpack://b101/./src/Savior/FirstAidPickup.ts","webpack://b101/./src/Savior/Warrok.ts","webpack://b101/./src/Savior/SkeletonZombie.ts","webpack://b101/./src/Savior/Boss.ts","webpack://b101/./src/Savior/TorchPowerup.ts","webpack://b101/./src/Savior/MedalPowerup.ts","webpack://b101/./src/Savior/Level.ts","webpack://b101/./src/Savior/Weapon.ts","webpack://b101/./src/Savior/Player.ts","webpack://b101/./src/Savior/UI.ts","webpack://b101/./src/Savior/M60.ts","webpack://b101/./src/Savior/Pistol.ts","webpack://b101/./src/Savior/Minigun.ts","webpack://b101/./src/Savior/FirstPersonController.ts","webpack://b101/./src/Savior/MainMenu.ts","webpack://b101/./src/components/Savior.vue?dae2","webpack://b101/./src/App.vue?7ccd","webpack://b101/./src/main.ts","webpack://b101/webpack/bootstrap","webpack://b101/webpack/runtime/chunk loaded","webpack://b101/webpack/runtime/define property getters","webpack://b101/webpack/runtime/global","webpack://b101/webpack/runtime/hasOwnProperty shorthand","webpack://b101/webpack/runtime/publicPath","webpack://b101/webpack/runtime/jsonp chunk loading","webpack://b101/webpack/startup"],"sourcesContent":["import { resolveComponent as _resolveComponent, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _component_Savior = _resolveComponent(\"Savior\")!\n\n  return (_openBlock(), _createBlock(_component_Savior))\n}","<template>\n  \n  <Savior />\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue';\nimport Savior from './components/Savior.vue';\n\nexport default defineComponent({\n  name: 'App',\n  components: {\n    Savior\n  }\n});\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n /*  margin-top: 60px; */\n}\n</style>\n","import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\nimport _imports_0 from '@/assets/saviorlogo.png'\nimport _imports_1 from '@/assets/olympiclogo.png'\n\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-5f2857f2\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = /*#__PURE__*/_createStaticVNode(\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" data-v-5f2857f2><div class=\\\"banner\\\" data-v-5f2857f2><div class=\\\"logo-container\\\" data-v-5f2857f2><img src=\\\"\" + _imports_0 + \"\\\" id=\\\"saviorlogo\\\" data-v-5f2857f2><img src=\\\"\" + _imports_1 + \"\\\" id=\\\"olympicLogo\\\" data-v-5f2857f2></div></div>\", 2)\nconst _hoisted_3 = { ref: \"canvas\" }\nconst _hoisted_4 = /*#__PURE__*/_createStaticVNode(\"<footer class=\\\"footer\\\" data-v-5f2857f2><p class=\\\"footer-text\\\" data-v-5f2857f2>Credits: First person weapon models by <a href=\\\"https://sketchfab.com/bumstrum\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-5f2857f2>3DMaesen (bumstrum)</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-5f2857f2>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-5f2857f2> Torch model <a href=\\\"https://sketchfab.com/leondp\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-5f2857f2>Nortenko Dmytro</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-5f2857f2>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-5f2857f2> Olympic medal <a href=\\\"https://sketchfab.com/AlbertoLuviano\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-5f2857f2>Alberto Luviano</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-5f2857f2>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-5f2857f2> Health kit <a href=\\\"https://sketchfab.com/stefanocagnani1990\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-5f2857f2>Stefano Cagnani</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-5f2857f2>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-5f2857f2>Credit to <a href=\\\"https://www.FesliyanStudios.com\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-5f2857f2>FesliyanStudios</a> for the background music </p></footer>\", 1)\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  return (_openBlock(), _createElementBlock(\"div\", null, [\n    _hoisted_1,\n    _createElementVNode(\"canvas\", _hoisted_3, null, 512),\n    _hoisted_4\n  ]))\n}","<template>\n  <div>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    \n    <div class=\"banner\">\n      <div class=\"logo-container\">\n        <img src=\"@/assets/saviorlogo.png\" id=\"saviorlogo\" />\n        <img src=\"@/assets/olympiclogo.png\" id=\"olympicLogo\" />\n      </div>\n    </div>\n\n    <canvas ref=\"canvas\"></canvas>\n\n    <footer class=\"footer\">\n      <p class=\"footer-text\">Credits: First person weapon models by <a href=\"https://sketchfab.com/bumstrum\" target=\"_blank\" class=\"credit-link\">3DMaesen (bumstrum)</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      <p class=\"footer-text\"> Torch model <a href=\"https://sketchfab.com/leondp\" target=\"_blank\" class=\"credit-link\">Nortenko Dmytro</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      <p class=\"footer-text\"> Olympic medal <a href=\"https://sketchfab.com/AlbertoLuviano\" target=\"_blank\" class=\"credit-link\">Alberto Luviano</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      <p class=\"footer-text\"> Health kit <a href=\"https://sketchfab.com/stefanocagnani1990\" target=\"_blank\" class=\"credit-link\">Stefano Cagnani</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      \n      <p class =\"footer-text\">Credit to <a href=\"https://www.FesliyanStudios.com\" target=\"_blank\" class=\"credit-link\">FesliyanStudios</a> for the background music </p>\n    </footer>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue';\nimport { FirstPersonController } from '@/Savior/FirstPersonController';\nimport { MainMenu } from '@/Savior/MainMenu';\n\nexport default defineComponent({\n  name: 'SaviorComponent',\n  mounted() {\n    const canvas = this.$refs.canvas as HTMLCanvasElement;\n    //new FirstPersonController(canvas);\n    const mainMenu = new MainMenu(canvas);\n  }\n});\n</script>\n\n<style scoped>\n canvas {\n    width: 100%;\n    height: 100%;\n    position: relative;\n    /* margin-bottom:20px; */\n  }\n\n  .footer {\n    position: absolute bottom;  \n    margin-top: auto;\n    bottom: 0;\n    width: 100%;\n   \n    text-align: center;\n    background-color: rgba(255, 255, 255, 0.5); \n    padding: 4px;\n    \n  }\n\n  .banner {\n    width: 100%;\n    text-align: center;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    background-color: rgba(255, 255, 255, 0.5); \n  }\n\n  .logo-container {\n    position: relative;\n    display: inline-block;\n  }\n\n  #olympicLogo {\n    width: 70%; \n    height: auto; \n    margin-top: 15%; \n  }\n\n  #saviorlogo {\n    width: 100%; \n    height: auto; \n    position: absolute;\n    top: 0;\n    left: 50%;\n    transform: translateX(-50%);\n  }\n\n\n  .credit-link, .license-link {\n    color: #0a4ca3; \n    text-decoration: none;\n    font-weight: bold;\n  }\n\n  .credit-link:hover, .license-link:hover {\n    text-decoration: underline;\n  }\n\n  .footer-text {\n    font-size: 10px;\n    margin: 2px 0;\n  }\n</style>\n","import { AbstractMesh, Tags, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Texture, TransformNode, Vector3, Axis } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\nimport { Player } from \"./Player\";\r\nimport { Level } from \"./Level\";\r\n\r\n\r\nexport class Enemy {\r\n    scene: Scene;\r\n    animationGroups: AnimationGroup[] = [];\r\n    health: number;\r\n    name: string;\r\n    mesh: AbstractMesh | null; // Property to store the mesh\r\n    rootMesh: AbstractMesh | null;\r\n    id: number; // Unique identifier for the enemy\r\n    isDead: boolean;\r\n\r\n    runSpeed!: number;\r\n    walkSpeed!: number;\r\n\r\n    damage!: number;\r\n    attackSpeed!: number;\r\n\r\n    attackSound!: Sound;\r\n\r\n\r\n\r\n    punch!: AnimationGroup;\r\n    run!: AnimationGroup;\r\n    idle!: AnimationGroup;\r\n    death!: AnimationGroup;\r\n    shot!: AnimationGroup;\r\n    walk!: AnimationGroup;\r\n    uppercut!: AnimationGroup;\r\n\r\n\r\n    randPosition!: Vector3;\r\n\r\n\r\n    aggroRange!: number;\r\n\r\n \r\n\r\n    transformNode!: TransformNode;\r\n    enemyCollider!: any;\r\n\r\n    collider: any;\r\n\r\n\r\n    appliesDot: boolean;\r\n    isSpellCasting!: boolean;\r\n\r\n\r\n    isAttacking: boolean;\r\n    isReacting: boolean;\r\n\r\n\r\n    scoreValue!: number;\r\n\r\n    static enemyCount = 0; \r\n    states: { DESTROYED: boolean; FOLLOWING: boolean; ATTACKING: boolean; };\r\n    attackTimer: any;\r\n    level: Level;\r\n   \r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        this.scene = scene;\r\n\r\n     \r\n\r\n        this.level = level;\r\n        this.isSpellCasting = false;\r\n        this.health = 100;\r\n        this.name = \"Monster\";\r\n        this.mesh = null; \r\n        this.rootMesh = null;\r\n        this.isDead = false;\r\n        \r\n        this.appliesDot = false;\r\n        this.id = ++Enemy.enemyCount; \r\n\r\n        this.states = {\r\n            'DESTROYED': false,\r\n            'FOLLOWING': false,\r\n            'ATTACKING': false,\r\n        };\r\n\r\n        this.isAttacking = false;\r\n        this.isReacting = false;\r\n\r\n        this.generateRandomPosition();\r\n\r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n        \r\n            const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync('', './models/', 'mutant.glb');\r\n    \r\n            \r\n            meshes[1].scaling= new Vector3(2,2,2);\r\n            \r\n            //meshes[0].position = position;\r\n            meshes[1].position = position;\r\n\r\n\r\n            \r\n            this.animationGroups = animationGroups;\r\n\r\n            this.mesh = meshes[1];\r\n            this.rootMesh = meshes[0];\r\n            this.mesh.checkCollisions = true;\r\n\r\n\r\n            Tags.AddTagsTo(this.mesh, \"enemy\");\r\n          \r\n            \r\n            animationGroups[0].stop();\r\n            animationGroups[2].play(true);\r\n\r\n    \r\n\r\n/* \r\n        \r\n        this.enemyCollider = MeshBuilder.CreateBox(\"enemyCollider\", {\r\n                width:1,\r\n                height: 1.7,\r\n                depth: 1\r\n            });\r\n            this.enemyCollider.isPickable = false;\r\n            \r\n           this.enemyCollider.position = this.mesh.position;\r\n           this.enemyCollider.position.y = 1; */\r\n\r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n    // Ajouter un observateur pour détecter la fin de l'animation du groupe 3\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n           // Une fois que l'animation du groupe 3 est terminée, reprendre l'animation du groupe 1\r\n           this.animationGroups[1].start(false);\r\n this.animationGroups[1].onAnimationEndObservable.addOnce(() => {\r\n   \r\n    this.animationGroups[1].pause();\r\n}\r\n );\r\n \r\n\r\n    console.log(\"WARROK DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n    console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n\r\n    this.animationGroups[5].play(false);\r\n // Ajouter un observateur pour détecter la fin de l'animation du groupe 3\r\n    this.animationGroups[5].onAnimationEndObservable.addOnce(() => {\r\n        // Une fois que l'animation du groupe 3 est terminée, reprendre l'animation du groupe 1\r\n        this.animationGroups[2].start(true);\r\n    });\r\n\r\n\r\n    console.log(\"WARROK SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n    console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n    console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n    console.log(\"RUN\");\r\n}\r\n\r\nupdateEnemyAnimations() {\r\n    if (this.states.DESTROYED) return;\r\n\r\n    if (this.states.FOLLOWING || this.states.ATTACKING) {\r\n  \r\n        this.runAnimation();\r\n    } else {\r\n\r\n\r\n        if(!this.isSpellCasting) {\r\n        this.idleAnimation();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nmove(player: Player): void {\r\n    if(this.states.DESTROYED) return;\r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n\r\n    if(distanceFromPlayer <= 2.5) \r\n    {\r\n        this.attackPlayer(player);\r\n\r\n    } \r\n    else if(distanceFromPlayer <= this.aggroRange) \r\n    {\r\n\r\n        if(!this.isAttacking && !this.isReacting) {\r\n            this.followPlayer(player);\r\n        }\r\n    } \r\n}\r\n\r\n\r\ngenerateRandomPosition() {\r\n    const randomPositionX = Math.floor((Math.random() * 100)) - (100 / 2);\r\n    const randomPositionZ = Math.floor((Math.random() * 100)) - (100 / 2);\r\n    \r\n\r\n    this.randPosition = new Vector3(randomPositionX, 0, randomPositionZ);\r\n}\r\n\r\nfollowPlayer(player: Player): void {\r\n    this.runAnimation();\r\n    this.states.ATTACKING = false;\r\n    this.states.FOLLOWING = true;\r\n\r\n       \r\n\r\n    const direction = player.position.subtract(this.rootMesh!.position).normalize();\r\n\r\n    \r\n    const alpha = Math.atan2(-direction.x, -direction.z);\r\n  \r\n\r\n    this.rootMesh!.rotation.y =  alpha;\r\n \r\n\r\n      \r\n       this.collider!.moveWithCollisions(direction.multiplyByFloats(this.runSpeed, 0, this.runSpeed));\r\n\r\n\r\n   \r\n}\r\n\r\nattackPlayer(player: Player): void {\r\n \r\n    \r\n\r\n    this.states.FOLLOWING = false;\r\n    this.states.ATTACKING = true;\r\n\r\n  \r\n\r\n    if (!this.attackTimer) {\r\n        const attackInterval = 1000 / this.attackSpeed; \r\n\r\n        const attackOnce = () => {\r\n            if (this.states.DESTROYED) {\r\n              \r\n                clearInterval(this.attackTimer);\r\n                this.attackTimer = null;\r\n                return;\r\n            }\r\n\r\n            if (this.isPlayerInRange(player)) {\r\n                if (player.health > 0) {\r\n                    player.health = Math.max(player.health-this.damage);\r\n\r\n                    if(this.appliesDot && !player.hasDot) {\r\n                        player.applyDot(2, 5000);\r\n                    }\r\n                   \r\n                    this.punchAnimation();\r\n                    this.attackSound.play();\r\n                   \r\n                } else {\r\n                    console.log(\"Player defeated!\");\r\n                }\r\n            }\r\n        };\r\n\r\n      \r\n        attackOnce();\r\n\r\n       \r\n        this.attackTimer = setInterval(attackOnce, attackInterval);\r\n    }\r\n}\r\n\r\n\r\nisPlayerInRange(player: Player): boolean {\r\n   \r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n    return distanceFromPlayer <= 3.5; \r\n}\r\n\r\n\r\nremove() {\r\n    if (!this.mesh || !this.rootMesh) return;\r\n\r\n \r\n   \r\n    if (this.attackTimer) {\r\n        clearInterval(this.attackTimer);\r\n        this.attackTimer = null;\r\n    }\r\n\r\n   \r\n\r\n\r\n   \r\n    setTimeout(() => {\r\n        this.mesh!.dispose();\r\n        this.rootMesh!.dispose();\r\n       \r\n\r\n     \r\n        this.states.DESTROYED = true;\r\n\r\n       \r\n    }, 25000);\r\n}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3, AbstractMesh } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Level } from \"./Level\";\r\n\r\n\r\nexport class Mutant extends Enemy {\r\n    \r\n  \r\n    \r\n\r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"Mutant\";\r\n        this.damage = 5;\r\n        this.scoreValue = 50;\r\n        this.attackSpeed = 0.4;\r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n\r\n        this.health = 150;\r\n\r\n    //this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    \r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n       \r\n        \r\n        const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync('', './models/', 'mutant2.glb');\r\n    \r\n   \r\n        this.mesh = meshes[1];\r\n        this.rootMesh = meshes[0];\r\n       \r\n        /* this.rootMesh.physicsImpostor = new PhysicsImpostor(\r\n            this.rootMesh,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 1, restitution: 0.1, friction: 0 },\r\n            this.scene\r\n        );\r\n */\r\n\r\n        this.rootMesh!.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n      \r\n        \r\n        this.rootMesh!.position = position;\r\n        this.collider.position = this.rootMesh!.position.clone();\r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n            \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n\r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n        this.animationGroups = animationGroups;\r\n        this.death =  this.animationGroups[1];\r\n        this.idle =  this.animationGroups[2];\r\n        this.punch =  this.animationGroups[3];\r\n        this.run =  this.animationGroups[4];\r\n        this.shot =  this.animationGroups[5];\r\n        this.uppercut =  this.animationGroups[6];\r\n        this.walk =  this.animationGroups[7];\r\n    \r\n     \r\n    \r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        this.animationGroups[0].stop();\r\n        this.animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.3;\r\n        this.walkSpeed = 0.07;\r\n    \r\n\r\n     \r\n\r\n\r\n\r\n       \r\n     \r\n\r\n     \r\n\r\n            this.scene.registerBeforeRender(() => {\r\n               \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n      \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5); \r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n        this.collider.isVisible = false;\r\n    \r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n    \r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n    this.remove();\r\n \r\n    //console.log(\" DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    this.idle.start(false);\r\n    //console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n    this.isReacting = true;\r\n    this.shot.play(false);\r\n\r\n    this.shot.onAnimationEndObservable.addOnce(() => {\r\n        this.isReacting = false;\r\n    });\r\n    //console.log(\" SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n   this.isAttacking = true;\r\n   this.punch.start(false);\r\n\r\n   this.punch.onAnimationEndObservable.addOnce(() => {\r\n        this.isAttacking = false;\r\n    \r\n});\r\n\r\n   \r\n   //return this.animationGroups[1];\r\n    //console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n    //console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n    // Check if any other animation group is currently playing\r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n    // Start the \"run\" animation group only if no other animation is currently playing\r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.start(true);\r\n        //console.log(\"RUN\");\r\n    }\r\n}\r\n\r\ncloneAnimationGroups(sourceAnimationGroups: AnimationGroup[], targetMesh: AbstractMesh): AnimationGroup[] {\r\n    return sourceAnimationGroups.map(sourceGroup => {\r\n        const newGroup = new AnimationGroup(sourceGroup.name);\r\n        \r\n        sourceGroup.targetedAnimations.forEach(targetedAnim => {\r\n            const newAnim = targetedAnim.animation.clone();\r\n            newGroup.addTargetedAnimation(newAnim, targetMesh);\r\n        });\r\n        \r\n        return newGroup;\r\n    });\r\n\r\n\r\n}\r\n\r\n\r\n}","import { AbstractMesh, Animation, Vector3, Scene, SceneLoader, FreeCamera, Sound, MeshBuilder, StandardMaterial, Texture, SpriteManager, Sprite, GlowLayer, Color3, Color4, Mesh, EasingFunction } from \"@babylonjs/core\";\r\n\r\nexport class WeaponPickups {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    spriteManager: any;\r\n    glowLayer: GlowLayer;\r\n\r\n    constructor() {\r\n        this.mesh = null;\r\n       this.pickupSound = new Sound(\r\n        \"weaponPickup\",\r\n        \"./audio/pickups/ammobox.mp3\",\r\n        this.scene,\r\n        null,\r\n        {\r\n            //spatialSound: true,\r\n            volume: 1,\r\n            autoplay: false\r\n        });\r\n\r\n\r\n        //this.spriteManager = new SpriteManager(\"spriteManager\", \"textures/arrow.png\", 1, 256, this.scene);\r\n\r\n\r\n        this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n        this.glowLayer.intensity = 1; \r\n\r\n    }\r\n\r\n\r\n\r\n    async CreateMinigunPickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'minigun.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.01, 0.01, 0.01);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"minigunPickup\";\r\n\r\n     /*    const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow); */\r\n       \r\n        \r\n    }\r\n\r\n\r\n    async CreatePistolPickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'pistol2.glb');\r\n        this.mesh = meshes[0]; \r\n       this.mesh.scaling = new Vector3(0.02, 0.02, 0.02);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"pistolPickup\";\r\n\r\n   /*      const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow); */\r\n       \r\n        \r\n    }\r\n\r\n    async CreateRiflePickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'rifle2.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.02, 0.02, 0.02);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"riflePickup\";\r\n\r\n        /* const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow);\r\n        */\r\n        \r\n    }\r\n\r\n    async CreateLMGPickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'lmg2.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(2, 2, 2);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"lmgPickup\";\r\n\r\n        /* const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow); */\r\n    }\r\n\r\n\r\n\r\n\r\n    /* async createGlowingArrow(parent: any) {\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/', 'arrow.glb');\r\n        const arrowMesh = meshes[0] as Mesh;\r\n        arrowMesh.scaling = new Vector3(0.5,0.5,0.5);\r\n     \r\n    \r\n        const arrowMaterial = new StandardMaterial('arrowMaterial', this.scene);\r\n        arrowMaterial.emissiveColor = Color3.FromHexString('#00FF00'); \r\n\r\n        arrowMesh.material = arrowMaterial;\r\n   \r\n         \r\n        // Parent arrow to the  mesh\r\n        arrowMesh.setParent(parent);\r\n\r\n        arrowMesh.position = parent.position.clone();\r\n        \r\n        \r\n       return arrowMesh;\r\n\r\n\r\n\r\n        \r\n\r\n        \r\n    }\r\n */\r\n\r\n  /*   CreateAnimations(mesh: any) {\r\n        const rotateFrames = [];\r\n        const fps = 60;\r\n\r\n        const rotateAnim = new Animation(\"rotateAnim\", \"rotation.y\", fps, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n\r\n        rotateFrames.push({frame: 0, value:0});\r\n        rotateFrames.push({frame: 180, value:Math.PI/2});\r\n\r\n\r\n        rotateAnim.setKeys(rotateFrames);\r\n\r\n\r\n        mesh.animations.push(rotateAnim);\r\n\r\n\r\n        this.scene.beginAnimation(mesh, 0, 180 )\r\n    }\r\n     */\r\n  \r\n}","import { AbstractMesh, Vector3, Scene, SceneLoader, FreeCamera, Sound, Mesh } from \"@babylonjs/core\";\r\n\r\nexport class AmmoPickup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    meshes: any;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n       this.pickupSound = new Sound(\r\n        \"ammoBoxPickup\",\r\n        \"./audio/pickups/ammobox.mp3\", \r\n        this.scene,\r\n        null,\r\n        {\r\n            //spatialSound: true,\r\n            volume: 1,\r\n            autoplay: false\r\n        });\r\n\r\n\r\n        this.camera = camera;\r\n        \r\n    }\r\n\r\n    async CreateAmmoPickup(position: Vector3) {\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/', 'ammocrate.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(-2.5, 2.5, 2.5);\r\n        this.mesh.position = position; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"ammoBox\";\r\n       \r\n        \r\n    }\r\n\r\n    collectAmmo() {\r\n\r\n        if (this.mesh) {\r\n            this.mesh.dispose();\r\n            this.mesh = null;\r\n        }\r\n    }\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n}\r\n}\r\n","import { AbstractMesh, Tags, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Texture, TransformNode, Vector3, Axis, RichTypeString } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\n\r\nexport class FirstAidPickup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    pickupSound: Sound;\r\n    scene!: Scene;\r\n    meshes: any;\r\n    camera!: FreeCamera;\r\n\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n        this.pickupSound = new Sound(\r\n            \"firstAidPickup\",\r\n            \"./audio/pickups/firstaid.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            });\r\n          this.camera = camera;\r\n    }\r\n\r\n    async CreateFirstAidPickup(position: Vector3) {\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/', 'firstaid.glb');\r\n        meshes[1].checkCollisions = true;\r\n        this.mesh = meshes[0];\r\n        meshes[0].scaling = new Vector3(-2.5,2.5,2.5);\r\n        this.mesh.position = position; \r\n        //this.mesh.checkCollisions = true;\r\n        meshes[1].id = \"firstAid\";\r\n    }\r\n\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n}","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3 } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Level } from \"./Level\";\r\n\r\n\r\nexport class Warrok extends Enemy {\r\n    \r\n  \r\n    \r\n\r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"Warrok\";\r\n        this.damage = 12;\r\n        this.scoreValue = 100;\r\n        this.attackSpeed = 0.4;\r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n        \r\n\r\n\r\n        \r\n    //this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    this.health = 120;\r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n\r\n        \r\n        const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync('', './models/', 'warrokk.glb');\r\n    \r\n   \r\n        this.mesh = meshes[1];\r\n        this.rootMesh = meshes[0];\r\n\r\n       \r\n\r\n        this.rootMesh.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n        \r\n        this.rootMesh.position = position;\r\n        this.collider.position = this.rootMesh.position.clone();\r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n            \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n     \r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n        this.animationGroups = animationGroups;\r\n        this.death = animationGroups[1];\r\n        this.idle = animationGroups[2];\r\n        this.punch = animationGroups[3];\r\n        this.run = animationGroups[4];\r\n        this.shot = animationGroups[5];\r\n        this.walk = animationGroups[2];\r\n    \r\n     \r\n    \r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        animationGroups[0].stop();\r\n        animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.2;\r\n        this.walkSpeed = 0.07;\r\n    \r\n        //console.log(animationGroups);\r\n\r\n\r\n     \r\n\r\n\r\n\r\n       \r\n\r\n            this.scene.registerBeforeRender(() => {\r\n                \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n    \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5); \r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n    \r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n        this.collider.isVisible = false;\r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n\r\n    this.remove();\r\n \r\n   // console.log(\" DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    this.idle.start(false);\r\n    //console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n    this.isReacting = true;\r\n    this.shot.play(false);\r\n\r\n    this.shot.onAnimationEndObservable.addOnce(() => {\r\n        this.isReacting = false;\r\n    });\r\n    //console.log(\" SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n   this.isAttacking = true;\r\n   this.punch.start(false);\r\n\r\n   this.punch.onAnimationEndObservable.addOnce(() => {\r\n        this.isAttacking = false;\r\n    \r\n});\r\n   \r\n   //return this.animationGroups[1];\r\n    //console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n    //console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n   \r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n   \r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.start(true);\r\n        \r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n}","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3 } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Level } from \"./Level\";\r\n\r\nexport class SkeletonZombie extends Enemy {\r\n    \r\n  \r\n    \r\n\r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"SkeletonZombie\";\r\n        this.damage = 10;\r\n        this.scoreValue = 200;\r\n        this.attackSpeed = 0.4;\r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n\r\n        this.health = 200;\r\n        \r\n    this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    \r\n    this.appliesDot = true;\r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n\r\n        \r\n        const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync('', './models/', 'skelezombie.glb');\r\n    \r\n    // Set monster properties\r\n        this.mesh = meshes[1];\r\n        this.rootMesh = meshes[0];\r\n\r\n        /* this.rootMesh.physicsImpostor = new PhysicsImpostor(\r\n            this.rootMesh,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 1, restitution: 0.1, friction: 0 },\r\n            this.scene\r\n        );\r\n */\r\n\r\n        this.rootMesh.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n        \r\n        this.rootMesh.position = position;\r\n        this.collider.position = this.rootMesh.position.clone();\r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n            \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n      // Create a box collider\r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n        this.animationGroups = animationGroups;\r\n        this.death = animationGroups[1];\r\n        this.idle = animationGroups[2];\r\n        this.punch = animationGroups[3];\r\n        this.run = animationGroups[4];\r\n        this.shot = animationGroups[5];\r\n        this.uppercut = animationGroups[3];\r\n        this.walk = animationGroups[6];\r\n    \r\n     \r\n    \r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        animationGroups[0].stop();\r\n        animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.6;\r\n        this.walkSpeed = 0.07;\r\n    \r\n  // Add physics impostor\r\n     \r\n\r\n\r\n\r\n       \r\n     \r\n\r\n\r\n            this.scene.registerBeforeRender(() => {\r\n               \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n      \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5);\r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n        this.collider.isVisible = false;\r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n    \r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n    this.remove();\r\n \r\n    //console.log(\" DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    this.idle.start(false);\r\n    //console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n    this.isReacting = true;\r\n    this.shot.play(false);\r\n\r\n    this.shot.onAnimationEndObservable.addOnce(() => {\r\n        this.isReacting = false;\r\n    });\r\n    //console.log(\" SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n\r\n\r\n   this.isAttacking = true;\r\n   this.punch.start(false);\r\n\r\n   this.punch.onAnimationEndObservable.addOnce(() => {\r\n        this.isAttacking = false;\r\n    \r\n});\r\n   \r\n   //return this.animationGroups[1];\r\n    //console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n    //console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n    // Check if any other animation group is currently playing\r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n    // Start the \"run\" animation group only if no other animation is currently playing\r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.start(true);\r\n       // console.log(\"RUN\");\r\n    }\r\n}\r\n\r\n\r\n}","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3, ParticleSystem, Texture, Color4, GlowLayer } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\n\r\nimport { Player } from \"./Player\";\r\nimport { Level } from \"./Level\";\r\nimport { Mutant } from \"./Mutant\";\r\nimport { SkeletonZombie } from \"./SkeletonZombie\";\r\nimport { Warrok } from \"./Warrok\";\r\n\r\n\r\nexport class Boss extends Enemy {\r\n    \r\n  \r\n    spellcast!: AnimationGroup;\r\n\r\n    spellParticles!: ParticleSystem;\r\n    isSpellCasting: boolean;\r\n    spellInterval!: number;\r\n\r\n    isVulnerable!: boolean;\r\n\r\n\r\n    player: Player;\r\n    glowInterval!: number;\r\n    glowLayer: any;\r\n    shockWaveSound: Sound;\r\n    shockWaveCastSound: Sound;\r\n    level: Level;\r\n    generateAddsInterval!: number;\r\n\r\n    constructor(scene: Scene, player: Player, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"Boss\";\r\n        this.level = level;\r\n        this.player = player;\r\n        this.scoreValue = 2000;\r\n        this.attackSpeed = 0.4;\r\n    \r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n\r\n        this.shockWaveSound = new Sound(\r\n            \"shockWaveSound\",\r\n            \"./audio/attack/shockwave.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                volume: 3,\r\n                autoplay: false\r\n            }\r\n        );\r\n        \r\n        this.shockWaveCastSound = new Sound(\r\n            \"shockWaveSound\",\r\n            \"./audio/attack/shockwaveCast.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 3,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        \r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n\r\n        this.health = 35000;\r\n\r\n        this.damage = 30;\r\n        this.isSpellCasting = false;\r\n\r\n\r\n        this.isVulnerable = true; // Initially, the boss is vulnerable\r\n        this.startVulnerabilityTimer();\r\n\r\n        \r\n    //this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    \r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n\r\n        this.collider.scaling = new Vector3(3,3,3);\r\n        this.collider.isVisible = false;\r\n        \r\n        const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync('', './models/', 'maw.glb');\r\n    \r\n    // Set monster properties\r\n        this.mesh = meshes[1];\r\n        this.rootMesh = meshes[0];\r\n\r\n        this.mesh.scaling = new Vector3(3,3,3);\r\n\r\n        /* this.rootMesh.physicsImpostor = new PhysicsImpostor(\r\n            this.rootMesh,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 1, restitution: 0.1, friction: 0 },\r\n            this.scene\r\n        );\r\n */\r\n\r\n        this.rootMesh.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n        \r\n        this.rootMesh.position = position;\r\n        this.collider.position = this.rootMesh.position.clone();\r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n            \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n      // Create a box collider\r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n        this.animationGroups = animationGroups;\r\n        this.death = animationGroups[1];\r\n        this.idle = animationGroups[2];\r\n        this.punch = animationGroups[3];\r\n        this.run = animationGroups[4];\r\n        this.shot = animationGroups[5];\r\n        this.uppercut = animationGroups[6];\r\n        this.spellcast = animationGroups[6];\r\n        this.walk = animationGroups[7];\r\n        \r\n    \r\n     \r\n        this.run.speedRatio = 0.2;\r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        animationGroups[0].stop();\r\n        animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.1;\r\n        this.walkSpeed = 0.07;\r\n    \r\n      \r\n     \r\n\r\n\r\n\r\n       \r\n     \r\n\r\n\r\n            this.scene.registerBeforeRender(() => {\r\n                \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            this.loadParticleSystem();\r\n\r\n\r\n\r\n\r\n            this.startSpellcastingInterval();\r\n            this.startAddGeneration();\r\n\r\n\r\n \r\n            this.shockWaveCastSound.attachToMesh(this.mesh);\r\n\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n      \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5); \r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n    \r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n    \r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n    this.remove();\r\n \r\n\r\n    this.level.stopWaveSystem();\r\n    clearInterval(this.generateAddsInterval);\r\n\r\n\r\n    this.death.onAnimationEndObservable.addOnce(()=> {\r\n        setTimeout(() => {\r\n        this.player.firstPersonController.ui.createWinScreen();\r\n        this.player.firstPersonController.camera.detachControl();\r\n    }, 5000);\r\n    });\r\n \r\n\r\n\r\n\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    if(!this.isSpellCasting) {\r\n        this.idle.start(true);\r\n    }\r\n\r\n}\r\n\r\nshotAnimation() {\r\n    this.shot.play(false);\r\n \r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n    this.isAttacking = true;\r\n    this.punch.start(false);\r\n \r\n    this.punch.onAnimationEndObservable.addOnce(() => {\r\n         this.isAttacking = false;\r\n     \r\n });\r\n   \r\n\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n\r\n}\r\n\r\nrunAnimation() {\r\n    // Check if any other animation group is currently playing\r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n    // Start the \"run\" animation group only if no other animation is currently playing\r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.speedRatio = 0.2; // Set the speed ratio to 0.5 to play at half speed\r\n\r\n        this.run.start(true);\r\n      \r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nspellAnimation() {\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n    this.isSpellCasting = true;\r\n    this.spellcast.start(false);\r\n    this.spellParticles.start();\r\n    this.shockWaveCastSound.play();\r\n\r\n    this.spellcast.onAnimationEndObservable.addOnce(() => {\r\n        this.isSpellCasting = false;\r\n        this.spellParticles.stop();\r\n        this.player.applyShockwave();\r\n\r\n        this.shockWaveCastSound.stop();\r\n        this.shockWaveSound.play();\r\n\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nloadParticleSystem() {\r\n    // Create and configure the particle system\r\nconst particleSystem = new ParticleSystem(\"particles\", 2000, this.scene);\r\n\r\n// Texture of each particle\r\nparticleSystem.particleTexture = new Texture(\"./textures/particles/spark_05.png\", this.scene);\r\n\r\n\r\nparticleSystem.emitter = this.rootMesh; \r\nparticleSystem.minEmitBox = new Vector3(1, 0, 1);\r\nparticleSystem.maxEmitBox = new Vector3(1, 0, 1);   \r\n\r\nparticleSystem.createSphereEmitter(9); \r\n\r\n// Colors of all particles\r\nparticleSystem.color1 = new Color4(0, 1, 1, 1.0);\r\nparticleSystem.color2 = new Color4(0, 1, 1, 1.0);\r\nparticleSystem.colorDead = new Color4(0, 1, 1, 0.0);\r\n\r\n\r\nparticleSystem.minSize = 2;\r\nparticleSystem.maxSize = 4;\r\n\r\n\r\nparticleSystem.minLifeTime = 0.2;\r\nparticleSystem.maxLifeTime = 0.2;\r\n\r\n\r\nparticleSystem.minInitialRotation = -Math.PI/3;\r\nparticleSystem.maxInitialRotation = Math.PI/3;\r\n\r\n// Emission rate\r\nparticleSystem.emitRate = 70;\r\n\r\n// Blend mode\r\nparticleSystem.blendMode = ParticleSystem.BLENDMODE_ONEONE;\r\n\r\n\r\n\r\n\r\n\r\n/* particleSystem.direction1 = new Vector3(15, 15, 0);\r\nparticleSystem.direction2 = new Vector3(0, 15, 15); */\r\n\r\n// Angular speed\r\n/* particleSystem.minAngularSpeed = 0;\r\nparticleSystem.maxAngularSpeed = Math.PI; */\r\n\r\n// Speed\r\n/* particleSystem.minEmitPower = 1;\r\nparticleSystem.maxEmitPower = 3;\r\nparticleSystem.updateSpeed = 0.007; */\r\n\r\n\r\nthis.spellParticles = particleSystem;\r\n//this.spellParticles.start();\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmove(player: Player): void {\r\n    if(this.states.DESTROYED) return;\r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n\r\n    if(distanceFromPlayer <= 5 && !this.isSpellCasting) \r\n    {\r\n        this.attackPlayer(player);\r\n\r\n    } \r\n    else if(distanceFromPlayer <= this.aggroRange && !this.isSpellCasting) \r\n    {\r\n\r\n        this.followPlayer(player);\r\n    } \r\n   \r\n}\r\n\r\n\r\n\r\nfollowPlayer(player: Player): void {\r\n    this.run.speedRatio = 0.2;\r\n    this.runAnimation();\r\n    this.states.ATTACKING = false;\r\n    this.states.FOLLOWING = true;\r\n\r\n       \r\n\r\n    const direction = player.position.subtract(this.rootMesh!.position).normalize();\r\n\r\n    \r\n    const alpha = Math.atan2(-direction.x, -direction.z);\r\n  \r\n\r\n    this.rootMesh!.rotation.y =  alpha;\r\n \r\n\r\n      \r\n       this.collider!.moveWithCollisions(direction.multiplyByFloats(this.runSpeed, 0, this.runSpeed));\r\n\r\n    \r\n   \r\n}\r\n\r\nattackPlayer(player: Player): void {\r\n \r\n\r\n    this.states.FOLLOWING = false;\r\n    this.states.ATTACKING = true;\r\n\r\n\r\n    if (!this.attackTimer) {\r\n        const attackInterval = 1000 / this.attackSpeed; // Interval between attacks in milliseconds\r\n\r\n        const attackOnce = () => {\r\n            if (this.states.DESTROYED) {\r\n                \r\n                clearInterval(this.attackTimer);\r\n                this.attackTimer = null;\r\n                return;\r\n            }\r\n\r\n            if (this.isPlayerInRange(player)) {\r\n                if (player.health > 0) {\r\n                    player.health = Math.max(player.health-this.damage);\r\n\r\n                    if(this.appliesDot && !player.hasDot) {\r\n                        player.applyDot(2, 5000);\r\n                    }\r\n                   \r\n                    this.punchAnimation();\r\n                    this.attackSound.play();\r\n                    //console.log(`Player attacked! Player's health: ${player.health}`);\r\n                } else {\r\n                   // console.log(\"Player defeated!\");\r\n                }\r\n            }\r\n        };\r\n\r\n     \r\n        attackOnce();\r\n\r\n        this.attackTimer = setInterval(attackOnce, attackInterval);\r\n    }\r\n}\r\n\r\n\r\nisPlayerInRange(player: Player): boolean {\r\n\r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n    return distanceFromPlayer <= 5; \r\n}\r\n\r\n\r\nstartSpellcastingInterval() {\r\n    this.spellInterval = setInterval(() => {\r\n        if (!this.isSpellCasting && !this.isDead) {\r\n            this.spellAnimation();\r\n        }\r\n    }, 15000); // 15000 milliseconds = 15 seconds\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nstartVulnerabilityTimer() {\r\n    this.glowInterval = setInterval(() => {\r\n        this.isVulnerable = !this.isVulnerable; // Toggle vulnerability\r\n        if (!this.isVulnerable) {\r\n            // If boss is not vulnerable, add glow effect\r\n            this.addGlowEffect();\r\n        } else {\r\n            // If boss is vulnerable, remove glow effect\r\n            this.removeGlowEffect();\r\n        }\r\n    }, 10000); // 10000 milliseconds = 10 seconds\r\n}\r\n\r\naddGlowEffect() {\r\n    // Create a glow layer\r\n    this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n    this.glowLayer.addIncludedOnlyMesh(this.rootMesh);\r\n\r\n    // Set glow properties\r\n    this.glowLayer.intensity = 3; \r\n    this.glowLayer.glowColor = new Color3(0, 1, 1);\r\n}\r\n\r\nremoveGlowEffect() {\r\n    // Dispose the glow layer\r\n    if (this.glowLayer) {\r\n        this.glowLayer.dispose();\r\n        this.glowLayer = null;\r\n    }\r\n}\r\n\r\n\r\n\r\nasync generateAdds(number: number) {\r\n    \r\n    const minX = -82; // Minimum X coordinate of the walls\r\n    const maxX = 12; // Maximum X coordinate of the walls\r\n    const minZ = -8; // Minimum Z coordinate of the walls\r\n    const maxZ = 115; // Maximum Z coordinate of the walls\r\n    for (let i = 0; i < number + 1; i++) {\r\n\r\n        // Generate random positions within the boundaries of the walls\r\n        const randomX = Math.random() * (maxX - minX) + minX;\r\n        const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n    \r\n        \r\n        const position = new Vector3(randomX, 0.1, randomZ);\r\n    \r\n        \r\n        const enemyTypes = [Mutant, SkeletonZombie, Warrok];\r\n    \r\n       \r\n        const EnemyClass = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];\r\n    \r\n       \r\n        const enemy = new EnemyClass(this.scene, this.level);\r\n        await enemy.CreateMonster(position);\r\n    \r\n        // Add the enemy to the list of enemies in the first-person controller\r\n        this.level.firstPersonController.enemies.push(enemy);\r\n    }\r\n    \r\n}\r\n\r\n\r\nstartAddGeneration() {\r\n    const GENERATE_ADDS_INTERVAL = 45000;\r\n    this.generateAddsInterval = setInterval(() => {\r\n        this.generateAdds(5); \r\n    }, GENERATE_ADDS_INTERVAL);\r\n}\r\n\r\n}","import { AbstractMesh, Vector3, Scene, SceneLoader, FreeCamera, Sound, Mesh, StandardMaterial, MeshBuilder, GlowLayer, Color3 } from \"@babylonjs/core\";\r\n\r\nexport class TorchPowerup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    glowLayer: GlowLayer;\r\n    scoreValue: number;\r\n\r\n    meshes: any;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n        this.scoreValue = 100;\r\n        this.pickupSound = new Sound(\r\n            \"\",\r\n            \"./audio/pickups/torch.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                volume: 2,\r\n                autoplay: false\r\n            }\r\n        );\r\n       this.camera = camera;\r\n        this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n        this.glowLayer.intensity = 1; \r\n    }\r\n\r\n    async CreateTorchPowerup(position: Vector3) {\r\n      \r\n        const sphereCollider = MeshBuilder.CreateSphere(\"sphereCollider\", {diameter: 0.1}, this.scene);\r\n        sphereCollider.isVisible = false; \r\n        sphereCollider.visibility = 0.5;\r\n        sphereCollider.isPickable = false; \r\n        sphereCollider.checkCollisions = true;\r\n        sphereCollider.scaling = new Vector3(15, 1, 15); \r\n\r\n        sphereCollider.position = position.clone(); \r\n        sphereCollider.position.y += 0.1;\r\n\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'torch.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.3, 0.3, 0.3);\r\n        this.mesh.position = position; \r\n\r\n\r\n        //this.meshes = meshes;\r\n\r\n  \r\n\r\n      \r\n        const glowMaterial = new StandardMaterial(\"glowMaterial\", this.scene);\r\n        glowMaterial.emissiveColor = new Color3(1, 1, 1); \r\n        glowMaterial.alpha = 0.5; \r\n        this.mesh.material = glowMaterial;\r\n\r\n        \r\n        this.mesh.setParent(sphereCollider);\r\n\r\n       \r\n        sphereCollider.id = \"torchPowerup\";\r\n\r\n\r\n       \r\n        setTimeout(() => {\r\n            sphereCollider.dispose();\r\n        }, 20000);\r\n    }\r\n\r\n    collectTorch() {\r\n        if (this.mesh && this.mesh.parent) {\r\n           \r\n            this.mesh.parent.dispose();\r\n            this.mesh = null;\r\n        }\r\n    }\r\n\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if(mesh){\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        }\r\n        });\r\n    }\r\n}\r\n}\r\n","import { AbstractMesh, Vector3, Scene, SceneLoader, FreeCamera, Sound, Mesh, StandardMaterial, MeshBuilder, GlowLayer, Color3 } from \"@babylonjs/core\";\r\n\r\nexport class MedalPowerup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    glowLayer: GlowLayer;\r\n    scoreValue: number;\r\n    meshes: any;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n        this.scoreValue = 100;\r\n        this.camera = camera;\r\n        this.pickupSound = new Sound(\r\n            \"\",\r\n            \"./audio/pickups/ammobox.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n       \r\n        this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n        this.glowLayer.intensity = 2; \r\n    }\r\n\r\n    async CreateMedalPowerup(position: Vector3) {\r\n        \r\n        const sphereCollider = MeshBuilder.CreateSphere(\"sphereCollider\", {diameter: 0.1}, this.scene);\r\n        sphereCollider.isVisible = false;\r\n        sphereCollider.visibility = 0.5;\r\n        sphereCollider.isPickable = false;\r\n        sphereCollider.scaling = new Vector3(28, 1, 28); \r\n        sphereCollider.position = position.clone(); \r\n        sphereCollider.checkCollisions = true;\r\n        //sphereCollider.position.y += 1;\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'medal.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.3, 0.3, 0.3);\r\n        this.mesh.position = position; \r\n\r\n       /*  this.meshes = meshes; */\r\n\r\n\r\n\r\n        \r\n        const glowMaterial = new StandardMaterial(\"glowMaterial\", this.scene);\r\n        glowMaterial.emissiveColor = new Color3(1, 1, 1); \r\n        glowMaterial.alpha = 0.5; \r\n        this.mesh.material = glowMaterial;\r\n\r\n       \r\n        this.mesh.setParent(sphereCollider);\r\n\r\n        \r\n        sphereCollider.id = \"medalPowerup\";\r\n\r\n        setTimeout(() => {\r\n            sphereCollider.dispose();\r\n        }, 20000);\r\n    }\r\n\r\n    collectMedal() {\r\n        if (this.mesh && this.mesh.parent) {\r\n          \r\n            this.mesh.parent.dispose();\r\n            this.mesh = null;\r\n        }\r\n    }\r\n\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if(mesh){\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        }\r\n        });\r\n    }\r\n}\r\n}\r\n","import { Scene, SceneLoader, Mesh, HemisphericLight, CubeTexture, Engine, Vector3, MeshBuilder, StandardMaterial, Color3, Sound, PBRMaterial, Texture, CannonJSPlugin , PhysicsImpostor, PointLight, ShadowGenerator, DirectionalLight, Light, LightGizmo, GizmoManager, ICullable, AbstractMesh} from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Mutant } from \"./Mutant\";\r\nimport * as CANNON from \"cannon\";\r\nimport { FirstPersonController } from \"./FirstPersonController\";\r\nimport { WeaponPickups } from \"./WeaponPickups\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { AmmoPickup } from \"./AmmoPickup\";\r\nimport { FirstAidPickup } from \"./FirstAidPickup\";\r\nimport { Warrok } from \"./Warrok\";\r\nimport { Boss } from \"./Boss\";\r\nimport { SkeletonZombie } from \"./SkeletonZombie\";\r\nimport { TorchPowerup } from \"./TorchPowerup\";\r\nimport { MedalPowerup } from \"./MedalPowerup\";\r\nimport { Instances } from \"./Instances\";\r\n\r\n\r\nexport class Level {\r\n    scene: Scene;\r\n    enemies!: Enemy[];\r\n    engine: Engine;\r\n    firstPersonController: FirstPersonController;\r\n    waveIntervalId: number | undefined; // Store the interval ID\r\n\r\n    waveNumber!: number;\r\n    nextWaveTime: number;\r\n\r\n    enemyNumber!: number;\r\n    weaponPickups: WeaponPickups;\r\n    firstaid: FirstAidPickup;\r\n    ammopickup: AmmoPickup;\r\n    torchPowerup: any;\r\n    medalPowerup: MedalPowerup;\r\n\r\n    meshes: any;\r\n    instances!: Instances;\r\n\r\n\r\n\r\n    constructor(engine: Engine, firstPersonController: FirstPersonController) {\r\n        this.engine = engine;\r\n\r\n        this.scene = this.CreateScene();\r\n        this.firstPersonController = firstPersonController;\r\n\r\n        this.waveNumber = 0;\r\n        this.nextWaveTime = 60;\r\n\r\n        this.engine.displayLoadingUI();\r\n        this.CreateEnvironment();\r\n        this.CreateImpostors();\r\n\r\n        this.createWall(new Vector3(-35, 0, -13));\r\n         this.createWall(new Vector3(-35, 0, 122));\r\n\r\n\r\n        this.createHWall(new Vector3(12,0,55));\r\n        this.createHWall(new Vector3(-82,0,55));\r\n\r\n\r\n        //this.CreateTorch();\r\n\r\n        this.weaponPickups = new WeaponPickups();\r\n        this.ammopickup = new AmmoPickup(this.scene, this.firstPersonController.camera);\r\n        this.firstaid = new FirstAidPickup(this.scene, this.firstPersonController.camera);\r\n        \r\n        this.torchPowerup = new TorchPowerup(this.scene, this.firstPersonController.camera);\r\n        this.medalPowerup = new MedalPowerup(this.scene, this.firstPersonController.camera);\r\n\r\n       // this.instances = new Instances();\r\n  \r\n  \r\n    }\r\n\r\n    \r\n    CreateScene(): Scene {\r\n        const scene = new Scene(this.engine);\r\n    \r\n        const hemilight = new HemisphericLight(\"hemi\", new Vector3(0,1,0), this.scene);\r\n    \r\n        hemilight.intensity = 0.3;\r\n        //const light = new PointLight(\"pointLight\", new Vector3(75, 50, -70), scene)\r\n        const light = new DirectionalLight(\"DirectionalLight\", new Vector3(-1, -1, -0.75), scene);\r\n\r\n        const envTex = CubeTexture.CreateFromPrefilteredData(\r\n            \"./environment/environment.env\",\r\n            scene\r\n          );\r\n\r\n          \r\n          light.intensity = 3;\r\n          //light.position = new Vector3(0,10,0);\r\n    /*       light.shadowEnabled = true;\r\n          light.shadowMinZ = 1;\r\n          light.shadowMaxZ = 10;  */\r\n\r\n       //this.CreateGizmos(light);\r\n\r\n          const shadowGen = new ShadowGenerator(2048, light);\r\n          shadowGen.useBlurCloseExponentialShadowMap = true;\r\n      \r\n          scene.environmentTexture = envTex;\r\n      \r\n          scene.createDefaultSkybox(envTex, true);\r\n      \r\n          scene.environmentIntensity = 0.5;\r\n    \r\n          scene.enablePhysics(new Vector3(0,-9.81,0), new CannonJSPlugin(true, 10, CANNON));\r\n    \r\n    \r\n    \r\n        \r\n        scene.collisionsEnabled = true;\r\n    \r\n        return scene;\r\n      }\r\n      CreateAsphalt(): PBRMaterial {\r\n        const pbr = new PBRMaterial(\"pbr\", this.scene);\r\n    \r\n        // Albedo texture\r\n        const albedoTexture = new Texture(\"./textures/grass/grass_diff.png\", this.scene);\r\n        albedoTexture.uScale = 200;\r\n        albedoTexture.vScale = 200;\r\n        pbr.albedoTexture = albedoTexture;\r\n    \r\n        // Bump texture\r\n        const bumpTexture = new Texture(\"./textures/grass/grass_norm.png\", this.scene);\r\n        bumpTexture.uScale = 200;\r\n        bumpTexture.vScale = 200;\r\n\r\n        pbr.bumpTexture = bumpTexture;\r\n        pbr.invertNormalMapX = true;\r\n        pbr.invertNormalMapY = true;\r\n    \r\n        // Metallic texture\r\n        const metallicTexture = new Texture(\"./textures/grass/grass_arm.jpg\", this.scene);\r\n        metallicTexture.uScale = 200;\r\n        metallicTexture.vScale = 200;\r\n        \r\n        pbr.metallicTexture = metallicTexture;\r\n    \r\n        pbr._useAmbientOcclusionFromMetallicTextureRed = true;\r\n        pbr.useRoughnessFromMetallicTextureGreen = true;\r\n        pbr.useMetallnessFromMetallicTextureBlue = true;\r\n    \r\n        return pbr;\r\n    }\r\n    \r\n  \r\n      async CreateEnvironment(): Promise<void> {\r\n         \r\n        const { meshes } = await SceneLoader.ImportMeshAsync(\r\n                \"\",\r\n                \"./models/\",\r\n                \"stadetest8.glb\",\r\n                this.scene\r\n            );\r\n\r\n\r\n    \r\n\r\n        meshes.forEach((mesh) => {\r\n\r\n       \r\n        // Enable collisions\r\n        //mesh.checkCollisions = true;\r\n        mesh.isPickable = true; \r\n        mesh.receiveShadows = true;\r\n\r\n\r\n        mesh.freezeWorldMatrix();\r\n        mesh.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;\r\n\r\n       // We remove non visible parts\r\n        if(mesh.name === \"Doors\"  || mesh.name === \"Stairs\" || mesh.name === \"Gates\" || \r\n        mesh.name === \"Entrance Steps\" || mesh.name ===\"End Terraces\" || mesh.name === \"Dividers\" || mesh.name === \"Doorknobs\" || mesh.name === \"Door Handles\" \r\n        || mesh.name ===\"Door Frames.\" || mesh.name === \"Ground Level\"\r\n        || mesh.name === \"Flag Pole Bases\" || mesh.name === \"Pressbox\" || mesh.name === \"Gates 02\" ) {\r\n        mesh.isVisible = false;\r\n       }\r\n      \r\n        \r\n     }); \r\n\r\n     this.meshes = meshes;\r\n    \r\n\r\n    \r\n      \r\n        const ground = MeshBuilder.CreateGround( \"ground\",\r\n        {width: 250, height: 250},\r\n        this.scene);\r\n\r\n        const groundMaterial = this.CreateAsphalt();\r\n\r\n       \r\n\r\n        ground.position = new Vector3(-35, 0.05, 55);\r\n      \r\n        ground.material = groundMaterial;\r\n                \r\n        \r\n        ground.checkCollisions = true; \r\n        ground.receiveShadows = true;\r\n        //ground.isVisible = false;\r\n\r\n        //ground.renderingGroupId = 0;\r\n\r\n         ground.physicsImpostor = new PhysicsImpostor(\r\n            ground,\r\n            PhysicsImpostor.BoxImpostor,\r\n            {mass:0, restitution:0}\r\n        ); \r\n        \r\n      \r\n \r\n\r\n     \r\n        //this.engine.setHardwareScalingLevel(1 / window.devicePixelRatio);\r\n\r\n     \r\n        //this.CreateTrack();\r\n\r\n         const backgroundMusic = new Sound(\r\n            \"backgroundMusic\",\r\n            \"./audio/background4.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                volume: 0.6,\r\n                autoplay: true,\r\n                loop: true\r\n          }\r\n        );\r\n\r\n\r\n        //this.engine.hideLoadingUI();\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    async generateEnemies(number: number): Promise<void> {\r\n        this.waveNumber+=1;\r\n\r\n        const minX = -81; \r\n        const maxX = 11;\r\n        const minZ = -7; \r\n        const maxZ = 114; \r\n   \r\n\r\n        if(this.waveNumber  == 2) {\r\n            this.firstPersonController.inventory.push(this.firstPersonController.rifle);\r\n            this.weaponPickups.CreateRiflePickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n           \r\n        }\r\n\r\n        if(this.waveNumber == 4) {\r\n            this.firstPersonController.inventory.push(this.firstPersonController.lmg);\r\n            this.weaponPickups.CreateLMGPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }\r\n\r\n        if(this.waveNumber == 7) {\r\n            this.firstPersonController.inventory.push(this.firstPersonController.minigun);\r\n            this.weaponPickups.CreateMinigunPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }\r\n\r\n\r\n\r\n        for (let i = 0; i < number + 1; i++) {\r\n      \r\n    \r\n          \r\n            const randomX = Math.random() * (maxX - minX) + minX;\r\n            const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n    \r\n           \r\n            const position = new Vector3(randomX, 0.1, randomZ);\r\n            const mutant = new Mutant(this.scene, this);\r\n            await mutant.CreateMonster(position);\r\n    \r\n            this.firstPersonController.enemies.push(mutant);\r\n        }\r\n\r\n\r\n\r\n        if(this.waveNumber >= 2) {\r\n            for (let i = 0; i < number -2 + 1; i++) {\r\n      \r\n    \r\n               \r\n                const randomX = Math.random() * (maxX - minX) + minX;\r\n                const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n        \r\n             \r\n                const position = new Vector3(randomX, 0.1, randomZ);\r\n                const warrok = new Warrok(this.scene, this);\r\n                await warrok.CreateMonster(position);\r\n        \r\n                this.firstPersonController.enemies.push(warrok);\r\n            }\r\n        }\r\n\r\n\r\n\r\n        if(this.waveNumber >= 4) {\r\n            for (let i = 0; i < number -2 + 1; i++) {\r\n      \r\n    \r\n               \r\n                const randomX = Math.random() * (maxX - minX) + minX;\r\n                const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n        \r\n               \r\n                const position = new Vector3(randomX, 0.1, randomZ);\r\n                const skeletonZombie = new SkeletonZombie(this.scene, this);\r\n                await skeletonZombie.CreateMonster(position);\r\n        \r\n                this.firstPersonController.enemies.push(skeletonZombie);\r\n        }\r\n    }\r\n\r\n\r\n    if(this.waveNumber === 8) {\r\n        this.stopWaveSystem();\r\n        this.nextWaveTime=0;\r\n\r\n       \r\n        const randomX = Math.random() * (maxX - minX) + minX;\r\n        const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n\r\n       \r\n        const position = new Vector3(randomX, 0.1, randomZ);\r\n        const boss = new Boss(this.scene, this.firstPersonController.player, this);\r\n        await boss.CreateMonster(position);\r\n\r\n        this.firstPersonController.enemies.push(boss);\r\n    }\r\n}\r\n    \r\n\r\n    startWaveSystem(): void {\r\n        \r\n        this.waveIntervalId = setInterval(() => {\r\n            this.generateEnemies(this.waveNumber);\r\n            this.nextWaveTime = 60;\r\n        }, 60000);\r\n\r\n\r\n\r\n        setInterval(() => {\r\n            if (this.nextWaveTime > 0) {\r\n                this.nextWaveTime -= 1;\r\n            }\r\n        }, 1000);\r\n    \r\n    \r\n    \r\n        this.startPickupGeneration();\r\n    \r\n    }\r\n\r\n    stopWaveSystem(): void {\r\n       \r\n        if (this.waveIntervalId !== undefined) {\r\n            clearInterval(this.waveIntervalId);\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    startPickupGeneration(): void {\r\n        \r\n\r\n        const minX = -82; \r\n        const maxX = 12;\r\n        const minZ = -8; \r\n        const maxZ = 115; \r\n\r\n\r\n        const minY = 0.1;\r\n        const maxY = 0.2;\r\n   \r\n\r\n        setInterval(() => {\r\n            this.ammopickup.CreateAmmoPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }, 60000); \r\n\r\n\r\n        setInterval(() => {\r\n            this.firstaid.CreateFirstAidPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }, 60000); \r\n\r\n\r\n\r\n        \r\n\r\n        setInterval(() => {\r\n            this.torchPowerup.CreateTorchPowerup(new Vector3(Math.random() * (maxX - minX) + minX,\r\n            Math.random() * (maxY - minY) + minY,\r\n            Math.random() * (maxZ - minZ) + minZ));\r\n          }, 20000); \r\n\r\n\r\n        setInterval(() => {\r\n            this.medalPowerup.CreateMedalPowerup(new Vector3(Math.random() * (maxX - minX) + minX,\r\n            Math.random() * (maxY - minY) + minY,\r\n            Math.random() * (maxZ - minZ) + minZ));\r\n        }, 20000); \r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    createWall(position: Vector3): void {\r\n        \r\n        const wallWidth = 95;\r\n        const wallHeight = 5;\r\n        const wallDepth = 0.5;\r\n        const wallPosition = position; \r\n\r\n       \r\n        const wall = MeshBuilder.CreateBox(\"wall\", { width: wallWidth, height: wallHeight, depth: wallDepth }, this.scene);\r\n\r\n       \r\n        wall.position = wallPosition;\r\n\r\n       \r\n        const wallMaterial = new StandardMaterial(\"wallMaterial\", this.scene);\r\n        wallMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5); \r\n        wall.material = wallMaterial;\r\n\r\n        wall.physicsImpostor = new PhysicsImpostor(\r\n            wall,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 0, restitution: 0, friction: 0 },\r\n            this.scene\r\n        );\r\n       \r\n        wall.checkCollisions = true;\r\n\r\n        wall.isVisible = false;\r\n        \r\n    }\r\n      \r\n    createHWall(position: Vector3): void {\r\n      \r\n        const wallWidth = 135;\r\n        const wallHeight = 15;\r\n        const wallDepth = 0.5;\r\n        const wallPosition = position; \r\n\r\n        \r\n        const wall = MeshBuilder.CreateBox(\"wall\", { width: wallWidth, height: wallHeight, depth: wallDepth }, this.scene);\r\n\r\n       \r\n        wall.position = wallPosition;\r\n        wall.rotation.y = Math.PI/2;\r\n\r\n       \r\n        const wallMaterial = new StandardMaterial(\"wallMaterial\", this.scene);\r\n        wallMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5); \r\n        wall.material = wallMaterial;\r\n\r\n        wall.physicsImpostor = new PhysicsImpostor(\r\n            wall,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 0, restitution: 0, friction: 0 },\r\n            this.scene\r\n        );\r\n        \r\n        wall.checkCollisions = true;\r\n        wall.isVisible = false;\r\n        \r\n    }\r\n\r\n    async CreateTorch() {\r\n        const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync(\"\", \"./models/pickups/\", \"torch.glb\");\r\n        meshes[0].position = new Vector3(-25, 0.5, 50);\r\n    }\r\n\r\n    CreateImpostors(): void {\r\n         const ground = MeshBuilder.CreateGround(\"groundImpostor\", {width:200, height:200 });\r\n         ground.isVisible = false;\r\n         ground.position.y += 0.05;\r\n          ground.physicsImpostor = new PhysicsImpostor(\r\n             ground,\r\n             PhysicsImpostor.BoxImpostor,\r\n             {mass:0, restitution:0}\r\n         ); \r\n\r\n         \r\n         this.firstPersonController.ground = ground;\r\n\r\n   \r\n\r\n        \r\n     }\r\n\r\n\r\n     async CreateTrack() {\r\n        const {meshes} = await SceneLoader.ImportMeshAsync(\r\n            \"\",\r\n             \"./models/\",\r\n             \"runtrack.glb\",\r\n             this.scene\r\n         );\r\n\r\n         meshes.forEach((mesh) => {\r\n            \r\n           \r\n            // Enable collisions\r\n            //mesh.checkCollisions = true;\r\n            mesh.receiveShadows = true;\r\n            mesh.position.y = 0.9\r\n            //mesh.isVisible = false;\r\n         }); \r\n     }\r\n\r\n     checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n        \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if (!this.firstPersonController.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n    }\r\n\r\n}","\r\nimport { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4 } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class Weapon {\r\n\r\n    camera: FreeCamera;\r\n    scene: Scene;\r\n    animationGroups!: AnimationGroup[];\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    gunMesh!: any;\r\n    gunMeshChild!: any;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n    enemies: Enemy[];\r\n    bulletHoleMaterial!: PBRMaterial;\r\n\r\n\r\n    shootSound!: Sound;\r\n    emptySound!: Sound;\r\n    reloadSound!: Sound;\r\n    readySound!: Sound;\r\n\r\n\r\n    isMeshCreated!: boolean;\r\n\r\n    toggleAutomatic!: boolean;\r\n    fireRate!: number;\r\n\r\n     muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n     isShootingAnimationPlaying: boolean;\r\n\r\n     isReadying: boolean;\r\n\r\n    damage: number;\r\n\r\n     player!: Player;\r\n    canvas: HTMLCanvasElement;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        this.camera = camera;\r\n        this.scene = scene;\r\n        this.player = player;\r\n\r\n        this.canvas = canvas;\r\n\r\n        this.isFiring = false;\r\n        this.isReloading = false;\r\n        this.isReadying = false;\r\n        this.ammo = 30;\r\n        this.enemies = enemies;\r\n        this.reloadAmmo = 90;\r\n        this.loadBulletholes();\r\n\r\n\r\n        this.fireRate = 100;\r\n\r\n\r\n        this.damage = 15;\r\n    \r\n        this.isShootingAnimationPlaying = false;\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n      \r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'rifle.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n    \r\n      \r\n        const transformNode = new TransformNode('glb');\r\n        \r\n\r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n       \r\n                \r\n                animationGroup.start(true, 0.3, 397, 458); //\r\n              \r\n               \r\n\r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        transformNode.parent = this.camera;\r\n\r\n        transformNode.position.y -= 0.2;\r\n        transformNode.position.z += 0.60;\r\n        transformNode.position.x += 0.32;\r\n        \r\n        \r\n        transformNode.scaling.set(0.01,0.01,0.01);\r\n   \r\n\r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/shoot.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/reload.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyRifle2.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n\r\n       // this.scene.getEngine().hideLoadingUI();\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        // plane.position.x= -size/2;\r\n        // plane.position.y= -size/2;\r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n\r\n       \r\n        \r\n\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 0.85, 0, 16);\r\n    \r\n\r\n            gun.isFiring = true;\r\n\r\n\r\n        // Start the muzzle flash particle system when the shooting animation begins\r\n        if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10); \r\n\r\n           /*  // Update the position of the particle system on each frame\r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n                // Update the position of the particle system to match the position of the gun mesh\r\n                this.muzzleFlashParticleSystem!.emitter = this.gunMesh;\r\n            }); */\r\n            \r\n        }\r\n\r\n    \r\n\r\n           \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                \r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n    \r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.3, 397, 458);\r\n            });\r\n            gun.isFiring = false; // Reset the flag\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n        gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 16, 176);\r\n    \r\n          \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    readyAnimation(gun: Weapon) {\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            //animationGroup.start(false, 1.25, 120, 176);\r\n            animationGroup.start(false, 1, 320, 396);\r\n\r\n\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                \r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readySfx() {\r\n        this.readySound.play();\r\n    }\r\n\r\n    shoot(): void {\r\n        if (this.ammo > 0 && !this.isReloading) {\r\n\r\n            this.shootSound.play();\r\n            \r\n         \r\n            const deviationAngle = Math.random() * Math.PI * 2; // Random angle between 0 and 2*pi\r\n            const deviationAmount = Math.random() * 0.04; // Random deviation amount\r\n            const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n            \r\n            \r\n            const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n            // Create the picking ray from the center of the screen\r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n        \r\n           \r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n          \r\n            if (raycastHit && raycastHit.hit) {\r\n              \r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                \r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n                    if(enemy) {\r\n                    \r\n                    enemy!.health -= this.damage;\r\n\r\n                    //console.log(\"dead?\" , enemy!.states.DESTROYED);\r\n\r\n                    if (enemy!.health > 0) {\r\n                        // Play shot animation on the enemy\r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                        // Play death animation if the enemy is killed\r\n                        this.playDeathAnimation(enemy!);\r\n\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                            \r\n                            if(enemy) {\r\n\r\n                            // this array\r\n                            const index = this.enemies.indexOf(enemy!);\r\n                         \r\n                            if (index !== -1) {\r\n                                \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n\r\n                            // fps array\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                                \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n\r\n\r\n\r\n\r\n\r\n                          \r\n\r\n                        }\r\n\r\n\r\n\r\n\r\n                        });\r\n\r\n\r\n\r\n                        //this.player.score += 1;\r\n                        //console.log(\"Player Score\", this.player.score);\r\n                        //enemy.rootMesh!.physicsImpostor!.setLinearVelocity(new Vector3(0,0,0));\r\n\r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n    \r\n            }\r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n// Dispose of the decal after 10 seconds\r\n                    setTimeout(() => {\r\n                        decal.dispose();\r\n                    }, 10000);\r\n                                \r\n                \r\n            }\r\n    \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n    }\r\n    \r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(30 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n    \r\n\r\n\r\n\r\n    playShotAnimation(enemy: Enemy): void {\r\n        // Trigger shot animation on the enemy that was hit\r\n        enemy.shotAnimation();\r\n    }\r\n    playDeathAnimation(enemy: Enemy): void {\r\n        // Trigger death animation on the enemy that was hit\r\n        enemy.deathAnimation();\r\n    }\r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n      \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n        // Load the bullet hole texture\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"textures/bullet_hole.png\", this.scene);\r\n\r\n        // Create a material with the bullet hole texture\r\n        \r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n       //this.bulletHoleMaterial.zOffset = -0.25;\r\n        /* this.splatter = new PBRMaterial(\"greenSplatter\", this.scene);\r\n        this.splatter.roughness = 1;\r\n        this.splatter.albedoTexture = new Texture(\"textures/green.png\", this.scene);\r\n        this.splatter.albedoTexture.hasAlpha = true;\r\n*/\r\n      \r\n    \r\n}\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    // Create particle system\r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    // Set particle texture\r\n    const texture = new Texture(\"./textures/particles/muzzle_05.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    // Set particle system properties\r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(15, 14, 100); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(15, 14, 100); \r\n \r\n    \r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange with 80% opacity\r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 0.3;\r\n    this.muzzleFlashParticleSystem.maxSize = 0.6;\r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01;\r\n    this.muzzleFlashParticleSystem.emitRate = 10;\r\n\r\n    \r\n\r\n    \r\n    \r\n\r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndispose(): void {\r\n    // Dispose of the gun mesh\r\n     // Dispose of the gun mesh and its children\r\n     if (this.gunMesh) {\r\n        this.gunMesh.dispose();\r\n        this.gunMesh = null;\r\n    }\r\n\r\n    // Optionally, set other properties to null or dispose of other objects\r\n}\r\n\r\n// Inside your Weapon class (or a superclass)\r\nasync preloadMesh(): Promise<void> {\r\n    if (!this.isMeshCreated) {\r\n        await this.CreateG(); // Create the mesh if it's not already created\r\n        if (this.gunMesh) {\r\n            this.gunMesh.setEnabled(false); // Hide the mesh\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { FreeCamera, Vector3, Animation, Scene, Sound } from \"@babylonjs/core\";\r\nimport { TextBlock } from \"@babylonjs/gui\";\r\nimport { FirstPersonController } from \"./FirstPersonController\";\r\n\r\nexport class Player {\r\n\r\n\r\n    health: number;\r\n    healthView!: TextBlock;\r\n    position!: Vector3;\r\n    maxHealth: number;\r\n    stamina: number;\r\n    maxStamina: number;\r\n\r\n    camera: FreeCamera;\r\n    scene: Scene;\r\n\r\n\r\n    score: number;\r\n\r\n    hasDot: boolean;\r\n\r\n    jumpingPower: number;\r\n\r\n\r\n    staminaRegenRate: number;\r\n    staminaDecayRate: number;\r\n\r\n\r\n    sprintSpeed: number;\r\n    walkSpeed: number;\r\n    firstPersonController: FirstPersonController;\r\n\r\n\r\n    isDecaying!: boolean;\r\n    isRegenerating!: boolean;\r\n\r\n    decayInterval!: number;\r\n    regenInterval!: number;\r\n\r\n\r\n    outOfBreath: Sound;\r\n\r\n    constructor(camera: FreeCamera, scene: Scene, firstPersonController: FirstPersonController) {\r\n\r\n        this.health = 100;\r\n        this.maxHealth = 100;\r\n        this.stamina = 100;\r\n        this.maxStamina = 100;\r\n        this.camera = camera;\r\n        this.scene = scene;\r\n        this.firstPersonController = firstPersonController;\r\n\r\n        this.hasDot = false;\r\n        this.score = 0;\r\n\r\n        this.jumpingPower = 5;\r\n\r\n        this.staminaRegenRate= 5;\r\n        this.staminaDecayRate = 10;\r\n\r\n        this.sprintSpeed = 3;\r\n        this.walkSpeed = 1.5;\r\n\r\n\r\n        this.outOfBreath = new Sound(\r\n            \"firstAidPickup\",\r\n            \"./audio/player/outofbreath.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound:true,\r\n                volume: 1,\r\n                autoplay:false\r\n            });\r\n    }\r\n\r\n\r\n    updatePosition(camera: FreeCamera) {\r\n        this.position = camera.position\r\n    }\r\n\r\n    screenJerk(duration = 100, intensity = 5) {\r\n         // Create glow overlay element\r\n        const glowOverlay = document.createElement('div');\r\n        glowOverlay.id = 'glow-overlay';\r\n        document.body.appendChild(glowOverlay);\r\n\r\n        // Remove the glow overlay after the specified duration\r\n        setTimeout(() => {\r\n            document.body.removeChild(glowOverlay);\r\n        }, duration);\r\n    }\r\n    \r\n    isDead(): boolean {\r\n        return this.health <= 0;\r\n    }\r\n\r\n\r\n\r\n    applyDot(damage: number, duration: number) {\r\n        // Calculate damage per second\r\n        const damagePerSecond = damage;\r\n    \r\n        // Apply initial damage\r\n        //this.health -= damagePerSecond;\r\n    \r\n        this.hasDot = true;\r\n        // Create timer for the damage-over-time effect\r\n        const dotTimer = setInterval(() => {\r\n            // Reduce health by damage per second\r\n            this.health = Math.max(this.health-damagePerSecond, 0);\r\n    \r\n            // Check if the duration has elapsed\r\n            duration -= 1000; // Subtract 1 second (1000 milliseconds)\r\n            if (duration <= 0) {\r\n                // Clear the timer and stop the damage-over-time effect\r\n                clearInterval(dotTimer);\r\n                this.hasDot = false;\r\n            }\r\n        }, 1000); // Repeat every 1 second (1000 milliseconds)\r\n    }\r\n\r\n\r\n    applyShockwave() {\r\n\r\n   /*      this.camera.speed = this.camera.speed * 0.5; */\r\n   const originalWalkSpeed = this.walkSpeed;\r\n   const originalSprintSpeed = this.sprintSpeed;\r\n   this.walkSpeed *= 0.5;\r\n   this.sprintSpeed *= 0.5;\r\n   this.firstPersonController.applyShockwave();\r\n        setTimeout(() => {\r\n            this.walkSpeed = originalWalkSpeed;\r\n            this.sprintSpeed = originalSprintSpeed;\r\n            /* this.camera.speed = originalCameraSpeed; */\r\n        }, 6000);\r\n\r\n        this.health = Math.max(0, this.health - 20);\r\n        this.firstPersonController.playerBox.applyImpulse(new Vector3(0,4,0), this.firstPersonController.playerBox.getAbsolutePosition());\r\n    }\r\n\r\n    decayStamina() {\r\n\r\n        this.isRegenerating = false;\r\n        if(!this.isDecaying && !this.isRegenerating) {\r\n\r\n        clearInterval(this.regenInterval);\r\n            // Interval for stamina decay\r\n         this.decayInterval = setInterval(() => {\r\n            // Reduce stamina by decay rate\r\n            this.stamina = Math.max(0, this.stamina - this.staminaDecayRate);\r\n            if (this.stamina === 0) {\r\n                // Clear the interval if stamina reaches zero\r\n                this.outOfBreath.play();\r\n                clearInterval(this.decayInterval);\r\n            }\r\n        }, 1000); // Decay every second (1000 milliseconds)\r\n    \r\n        this.isDecaying = true;\r\n\r\n    }\r\n    }\r\n    \r\n\r\n    regenStamina() {\r\n\r\n        this.isDecaying = false;\r\n        if(!this.isRegenerating && !this.isDecaying) {\r\n        clearInterval(this.decayInterval);\r\n        // Interval for stamina regeneration\r\n         this.regenInterval = setInterval(() => {\r\n            // Increase stamina by regen rate, capped at maxStamina\r\n            this.stamina = Math.min(this.maxStamina, this.stamina + this.staminaRegenRate);\r\n            if (this.stamina === this.maxStamina) {\r\n                // Clear the interval if stamina reaches max\r\n                clearInterval(this.regenInterval);\r\n            }\r\n        }, 1000); // Regen every second (1000 milliseconds)\r\n    \r\n        this.isRegenerating = true;\r\n    }\r\n    }\r\n\r\n\r\n\r\n}","import { AdvancedDynamicTexture, Button, Control, Rectangle, TextBlock } from \"@babylonjs/gui\";\r\nimport { Player } from \"./Player\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Level } from \"./Level\";\r\n\r\nexport class UI {\r\n\r\n\r\n    ammoTextBlock!: TextBlock;\r\n    healthBlock!: TextBlock;\r\n    staminaBlock!: TextBlock;\r\n    player: Player;\r\n    weapon: Weapon;\r\n    healthBar!: Rectangle;\r\n    staminaBar!: Rectangle;\r\n\r\n    inventory!: Weapon[];\r\n    currentWeaponIndex!: number;\r\n\r\n    coordinatesBlock!: TextBlock;\r\n    scoreBlock!: TextBlock;\r\n\r\n    level: Level;\r\n\r\n    waveBlock!: TextBlock;\r\n    waveTimeBlock!: TextBlock;\r\n\r\n    deathScreen!: Rectangle;\r\n    restartButton!:Button;\r\n\r\n    showDeathScreen: boolean;\r\n    showWinScreen: boolean;\r\n    winScreen: any;\r\n\r\n\r\n    pauseMenu!: Rectangle;\r\n    unpauseButton!: Button;\r\n\r\n    constructor(player: Player, weapon: Weapon, inventory: Weapon[], currentWeaponIndex: number, level: Level) {\r\n        this.player = player;\r\n        this.weapon = weapon;\r\n        \r\n        this.inventory = inventory;\r\n        this.currentWeaponIndex = currentWeaponIndex;\r\n       \r\n        this.showDeathScreen = false;\r\n        this.showWinScreen = false;\r\n\r\n        this.level = level;\r\n\r\n        this.loadText();\r\n        this.createPauseUI();\r\n    }\r\n\r\n    loadText(): void {\r\n        // Create a GUI texture\r\n        const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n    \r\n        // Create container for ammo text\r\n        const ammoContainer = new Rectangle();\r\n        ammoContainer.width = \"22%\";\r\n        ammoContainer.height = \"15%\";\r\n        ammoContainer.background = \"rgba(0, 0, 0, 0.45)\"; // Semi-transparent black background\r\n        ammoContainer.cornerRadius = 20; // Rounded corners\r\n        ammoContainer.thickness = 2; // Border thickness\r\n        ammoContainer.color = \"white\"; // Border color\r\n        ammoContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        ammoContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        ammoContainer.top = \"80%\";\r\n        ammoContainer.left = \"20%\";\r\n    \r\n     /*    // Add box shadow effect\r\n        ammoContainer.shadowBlur = 20; // Blur radius\r\n        ammoContainer.shadowOffsetX = 10; // Offset along X axis\r\n        ammoContainer.shadowOffsetY = 10; // Offset along Y axis\r\n        ammoContainer.shadowColor = \"#000000\"; // Shadow color\r\n     */\r\n        advancedTexture.addControl(ammoContainer);\r\n    \r\n        // Create a text block for ammo\r\n        this.ammoTextBlock = new TextBlock();\r\n        this.ammoTextBlock.color = \"rgb(0, 255, 0)\";\r\n        this.ammoTextBlock.fontFamily = \"Consolas\";\r\n        this.ammoTextBlock.fontWeight = \"bold\";\r\n        this.ammoTextBlock.fontSize = \"36vw\"; \r\n        ammoContainer.addControl(this.ammoTextBlock);\r\n    \r\n        this.updateAmmoText();\r\n    \r\n        // Create container for player health text\r\n        const healthContainer = new Rectangle();\r\n        healthContainer.width = \"15%\";\r\n        healthContainer.height = \"15%\";\r\n        healthContainer.background = \"rgba(0, 0, 0, 0.45)\";\r\n        healthContainer.cornerRadius = 20;\r\n        healthContainer.thickness = 2;\r\n        healthContainer.color = \"white\";\r\n        healthContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        healthContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        healthContainer.top = \"80%\";\r\n        healthContainer.left = \"3%\";\r\n    \r\n      /*   // Add box shadow effect\r\n        healthContainer.shadowBlur = 10; // Blur radius\r\n        healthContainer.shadowOffsetX = 5; // Offset along X axis\r\n        healthContainer.shadowOffsetY = 5; // Offset along Y axis\r\n        healthContainer.shadowColor = \"#000000\"; // Shadow color */\r\n    \r\n        advancedTexture.addControl(healthContainer);\r\n    \r\n        // Create a text block for player health\r\n        this.healthBlock = new TextBlock();\r\n        this.healthBlock.color = \"rgb(0, 255, 0)\";\r\n        this.healthBlock.fontFamily = \"Consolas\";\r\n        this.healthBlock.fontWeight = \"bold\";\r\n        this.healthBlock.fontSize = \"36vw\"; // Decreased font size for better fit\r\n      \r\n        healthContainer.addControl(this.healthBlock);\r\n\r\n\r\n\r\n     /* // Create a progress bar for player health\r\n     this.healthBar = new Rectangle();\r\n     this.healthBar.width = \"290px\";\r\n     this.healthBar.height = \"20px\";\r\n     this.healthBar.cornerRadius = 20;\r\n     this.healthBar.background = this.healthBlock.color; // Red color for the bar\r\n     this.healthBar.thickness = 1;\r\n     this.healthBar.color = \"darkgreen\";\r\n     this.healthBar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n     this.healthBar.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n     this.healthBar.top = \"70px\";\r\n     this.healthBar.left = \"10px\";\r\n \r\n     // Add box shadow effect\r\n     this.healthBar.shadowBlur = 5; // Blur radius\r\n     this.healthBar.shadowOffsetX = 2; // Offset along X axis\r\n     this.healthBar.shadowOffsetY = 2; // Offset along Y axis\r\n     this.healthBar.shadowColor = \"#000000\"; // Shadow color\r\n \r\n     advancedTexture.addControl(this.healthBar); */\r\n \r\n        this.updatePlayerHP();\r\n\r\n\r\n\r\n\r\n        // Create a container for stamina text\r\n       /*  const staminaContainer = new Rectangle();\r\n        staminaContainer.width = \"200px\";\r\n        staminaContainer.height = \"100px\";\r\n        staminaContainer.background = \"rgba(0, 0, 0, 0.45)\"; // Semi-transparent black background\r\n        staminaContainer.cornerRadius = 20; // Rounded corners\r\n        staminaContainer.thickness = 2; // Border thickness\r\n        staminaContainer.color = \"white\"; // Border color\r\n        staminaContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        staminaContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        staminaContainer.top = \"1%\";\r\n        staminaContainer.left = \"40%\"; */\r\n    \r\n     /*    // Add box shadow effect\r\n        staminaContainer.shadowBlur = 10; // Blur radius\r\n        staminaContainer.shadowOffsetX = 5; // Offset along X axis\r\n        staminaContainer.shadowOffsetY = 5; // Offset along Y axis\r\n        staminaContainer.shadowColor = \"#000000\"; // Shadow color */\r\n    \r\n        //advancedTexture.addControl(staminaContainer);\r\n\r\n\r\n         // Create a stamina progress bar\r\n        this.staminaBar = new Rectangle();\r\n        this.staminaBar.width = \"350px\"; // Initially full width\r\n        this.staminaBar.height = \"15px\";\r\n        this.staminaBar.cornerRadius = 20;\r\n        this.staminaBar.thickness = 1;\r\n        this.staminaBar.background = \"cyan\"; // Cyan color\r\n        this.staminaBar.color = \"black\";\r\n        this.staminaBar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.staminaBar.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.staminaBar.top = \"75%\";\r\n        this.staminaBar.left = \"5%\";\r\n\r\n                // Add box shadow effect\r\n        this.staminaBar.shadowBlur = 5; // Blur radius\r\n        this.staminaBar.shadowOffsetX = 2; // Offset along X axis\r\n        this.staminaBar.shadowOffsetY = 2; // Offset along Y axis\r\n        this.staminaBar.shadowColor = \"#000000\"; // Shadow color\r\n        \r\n        advancedTexture.addControl(this.staminaBar);\r\n     \r\n      /*   // Create a text block for stamina\r\n        this.staminaBlock = new TextBlock();\r\n        this.staminaBlock.color = \"cyan\";\r\n        this.staminaBlock.fontFamily = \"Consolas\";\r\n        this.staminaBlock.fontWeight = \"bold\";\r\n        this.staminaBlock.fontSize = 36; // Decreased font size for better fit\r\n        staminaContainer.addControl(this.staminaBlock); */\r\n    \r\n        this.updateStaminaText();\r\n\r\n\r\n\r\n\r\n                // Create a text block for player coordinates\r\n       /*  this.coordinatesBlock = new TextBlock();\r\n        this.coordinatesBlock.color = \"white\";\r\n        this.coordinatesBlock.fontFamily = \"Consolas\";\r\n        this.coordinatesBlock.fontWeight = \"bold\";\r\n        this.coordinatesBlock.fontSize = 18; \r\n        this.coordinatesBlock.text = \"(x, y, z): \"; // Initial text\r\n        this.coordinatesBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.coordinatesBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.coordinatesBlock.top = \"20px\";\r\n        this.coordinatesBlock.left = \"650px\";\r\n\r\n        advancedTexture.addControl(this.coordinatesBlock); */\r\n\r\n        // Assuming you have access to the player's coordinates, update the text accordingly\r\n        //this.updatePlayerCoordinates();\r\n\r\n\r\n\r\n\r\n\r\n        \r\n        const scoreContainer = new Rectangle();\r\n        scoreContainer.width = \"520px\";\r\n        scoreContainer.height = \"90px\";\r\n        scoreContainer.background = \"rgba(0, 0, 0, 0.45)\"; \r\n        scoreContainer.cornerRadius = 20; \r\n        scoreContainer.thickness = 2; \r\n        scoreContainer.color = \"white\"; \r\n        scoreContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        scoreContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        scoreContainer.top = \"1%\";\r\n        scoreContainer.left = \"25%\";\r\n\r\n        advancedTexture.addControl(scoreContainer);\r\n\r\n\r\n\r\n\r\n              \r\n        this.scoreBlock = new TextBlock();\r\n        this.scoreBlock.color = \"rgb(0, 255, 0)\";\r\n        this.scoreBlock.fontFamily = \"Consolas\";\r\n        this.scoreBlock.fontWeight = \"bold\";\r\n        this.scoreBlock.fontSize = \"18vw\"; \r\n        this.scoreBlock.text = \"Score: \"; \r\n   this.scoreBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.scoreBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.scoreBlock.top = \"53px\";\r\n        this.scoreBlock.left = \"200px\"; \r\n\r\n        scoreContainer.addControl(this.scoreBlock);\r\n\r\n\r\n        this.waveBlock = new TextBlock();\r\n        this.waveBlock.color = \"rgb(0, 255, 0)\";\r\n        this.waveBlock.fontFamily = \"Consolas\";\r\n        this.waveBlock.fontWeight = \"bold\";\r\n        this.waveBlock.fontSize = 18; \r\n        this.waveBlock.text = \"Wave: \"; \r\n        this.waveBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.waveBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.waveBlock.top = \"5px\";\r\n        this.waveBlock.left = \"200px\";\r\n\r\n        scoreContainer.addControl(this.waveBlock);\r\n\r\n        \r\n\r\n        this.waveTimeBlock = new TextBlock();\r\n        this.waveTimeBlock.color = \"rgb(0, 255, 0)\";\r\n        this.waveTimeBlock.fontFamily = \"Consolas\";\r\n        this.waveTimeBlock.fontWeight = \"bold\";\r\n        this.waveTimeBlock.fontSize = 18; \r\n        this.waveTimeBlock.text = \"Prochaine vague: \"; \r\n        this.waveTimeBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.waveTimeBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.waveTimeBlock.top = \"30px\";\r\n       this.waveTimeBlock.left = \"120px\";\r\n\r\n        scoreContainer.addControl(this.waveTimeBlock);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // Pause menu\r\n        \r\n    }\r\n    \r\n    createPauseUI(): void {\r\n        const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n        this.pauseMenu = new Rectangle();\r\n        this.pauseMenu.width = 0.5;\r\n        this.pauseMenu.height = 0.5;\r\n        this.pauseMenu.background = \"black\";\r\n        this.pauseMenu.alpha = 0.8;\r\n        this.pauseMenu.isVisible = false;\r\n        advancedTexture.addControl(this.pauseMenu);\r\n\r\n        const pauseText = new TextBlock();\r\n        pauseText.text = \"Paused\";\r\n        pauseText.color = \"white\";\r\n        pauseText.fontSize = 40;\r\n        this.pauseMenu.addControl(pauseText);\r\n\r\n        this.unpauseButton = Button.CreateSimpleButton(\"unpauseButton\", \"Unpause\");\r\n        this.unpauseButton.width = \"150px\";\r\n        this.unpauseButton.height = \"50px\";\r\n        this.unpauseButton.color = \"white\";\r\n        this.unpauseButton.background = \"gray\";\r\n        this.unpauseButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n        this.unpauseButton.top = \"-10px\";\r\n        this.pauseMenu.addControl(this.unpauseButton);\r\n    }\r\n\r\n    showPauseScreen(): void {\r\n        if (this.pauseMenu) {\r\n            this.pauseMenu.isVisible = true;\r\n        }\r\n    }\r\n\r\n    hidePauseScreen(): void {\r\n        if (this.pauseMenu) {\r\n            this.pauseMenu.isVisible = false;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    updateAmmoText(): void {\r\n       \r\n        this.ammoTextBlock.text = this.weapon.ammo.toString()+\" | \"+this.weapon.reloadAmmo.toString();\r\n        //this.ammoTextBlock.text = this.inventory[this.currentWeaponIndex].ammo.toString()+\" | \"+this.inventory[this.currentWeaponIndex].reloadAmmo.toString();\r\n    }\r\n\r\n \r\n    updateHealthBar(healthBar: Rectangle): void {\r\n        const healthPercentage = this.player.health / this.player.maxHealth;\r\n        healthBar.width = `${healthPercentage * 290}px`; \r\n        healthBar.background = this.healthBlock.color;\r\n    }\r\n\r\n    updatePlayerHP(): void {\r\n        const health = this.player.health;\r\n        this.healthBlock.text = health.toString();\r\n    \r\n       \r\n        let color = \"\";\r\n        if (health > 50) {\r\n            \r\n            const red = Math.floor(255 - (health - 50) * 5.1); \r\n            const green = 255;\r\n            color = `rgb(${red},${green},0)`;\r\n        } else {\r\n           \r\n            const green = Math.floor((health * 5.1));\r\n            const red = 255;\r\n            color = `rgb(${red},${green},0)`;\r\n        }\r\n    \r\n      \r\n        this.healthBlock.color = color;\r\n        //this.updateHealthBar(this.healthBar);\r\n    }\r\n\r\n\r\n    updateStaminaText(): void {\r\n       \r\n        //this.staminaBlock.text = this.player.stamina.toString();\r\n\r\n         const staminaPercentage = this.player.stamina / this.player.maxStamina;\r\n        this.staminaBar.width = `${staminaPercentage * 33}%`; \r\n    }\r\n    \r\n\r\n    // Function to update player coordinates text\r\n/* updatePlayerCoordinates() {\r\n\r\n\r\n\r\n    const playerX = 0;\r\n    const playerY =0;\r\n    const playerZ = 0;\r\n\r\n    \r\n\r\n    \r\n    this.coordinatesBlock.text = `(x: ${this.player.position.x.toFixed(2)}, y: ${this.player.position.y.toFixed(2)}, z: ${this.player.position.z.toFixed(2)})`;\r\n    \r\n} */\r\n\r\n\r\nupdatePlayerScore() {\r\n    this.scoreBlock.text = `Score: ${this.player.score}`;\r\n}\r\n\r\n\r\nupdateWaveNumber() {\r\n    this.waveBlock.text = `Vague: ${this.level.waveNumber}`;\r\n}\r\n\r\n\r\nupdateWaveTimer() {\r\n    this.waveTimeBlock.text = `Prochaine vague: ${this.level.nextWaveTime} secondes.`;\r\n}\r\n\r\n\r\n\r\ncreateDeathScreen(): void {\r\n    if(!this.showDeathScreen) {\r\n    const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n   \r\n    this.deathScreen = new Rectangle();\r\n    this.deathScreen.width = \"100%\";\r\n    this.deathScreen.height = \"100%\";\r\n    this.deathScreen.background = \"rgba(255, 0, 0, 0.5)\"; \r\n    this.deathScreen.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.deathScreen.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(this.deathScreen);\r\n\r\n\r\n\r\n\r\n    const youDiedText = new TextBlock();\r\n    youDiedText.text = \"Vous êtes mort\";\r\n    youDiedText.color = \"white\";\r\n    youDiedText.fontSize = 32;\r\n    youDiedText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    youDiedText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    youDiedText.top = \"-100px\"; // Adjust vertical position\r\n    this.deathScreen.addControl(youDiedText);\r\n\r\n  \r\n    const scoreText = new TextBlock();\r\n    scoreText.text = \"Score: \" + this.player.score;\r\n    scoreText.color = \"white\";\r\n    scoreText.fontSize = 24;\r\n    scoreText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    scoreText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    scoreText.top = \"-50px\"; // Adjust vertical position\r\n    this.deathScreen.addControl(scoreText);\r\n\r\n\r\n\r\n\r\n    \r\n    this.restartButton = Button.CreateSimpleButton(\"restartButton\", \"Rejouer\");\r\n    this.restartButton.width = \"200px\";\r\n    this.restartButton.height = \"50px\";\r\n    this.restartButton.color = \"white\";\r\n    this.restartButton.background = \"black\";\r\n    this.restartButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.restartButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n   \r\n    this.restartButton.onPointerUpObservable.add(() => {\r\n       \r\n        advancedTexture.removeControl(this.deathScreen);\r\n\r\n\r\n        location.reload();\r\n    \r\n    });\r\n\r\n    this.deathScreen.addControl(this.restartButton);\r\n    this.showDeathScreen = true;\r\n\r\n    this.level.stopWaveSystem();\r\n}\r\n}\r\n\r\n\r\n\r\ncreateWinScreen() {\r\n    if(!this.showWinScreen) {\r\n        const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n    \r\n    this.winScreen = new Rectangle();\r\n    this.winScreen.width = \"100%\";\r\n    this.winScreen.height = \"100%\";\r\n    this.winScreen.background = \"rgba(0, 255, 0, 0.5)\"; \r\n    this.winScreen.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.winScreen.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(this.winScreen);\r\n\r\n    const youWonText = new TextBlock();\r\n    youWonText.text = \"Vous avez gagné!\";\r\n    youWonText.color = \"white\";\r\n    youWonText.fontSize = 32;\r\n    youWonText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    youWonText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    youWonText.top = \"-100px\"; \r\n    this.winScreen.addControl(youWonText);\r\n    \r\n    const scoreText = new TextBlock();\r\n    scoreText.text = \"Score: \" + this.player.score;\r\n    scoreText.color = \"white\";\r\n    scoreText.fontSize = 24;\r\n    scoreText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    scoreText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    scoreText.top = \"-50px\"; \r\n    this.winScreen.addControl(scoreText);\r\n\r\n\r\n\r\n\r\n   \r\n    this.restartButton = Button.CreateSimpleButton(\"restartButton\", \"Rejouer\");\r\n    this.restartButton.width = \"200px\";\r\n    this.restartButton.height = \"50px\";\r\n    this.restartButton.color = \"white\";\r\n    this.restartButton.background = \"black\";\r\n    this.restartButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.restartButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n  \r\n    this.restartButton.onPointerUpObservable.add(() => {\r\n       \r\n        advancedTexture.removeControl(this.winScreen);\r\n\r\n\r\n        location.reload();\r\n    \r\n    });\r\n\r\n    this.winScreen.addControl(this.restartButton);\r\n    this.showWinScreen = true;\r\n\r\n    this.level.stopWaveSystem();\r\n\r\n    }\r\n}\r\n\r\n\r\n}","import { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4 } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class M60 extends Weapon {\r\n\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n\r\n\r\n    canFire!: boolean;\r\n    currentFireRate: number;\r\n\r\n    muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n\r\n\r\n   \r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        super(scene, camera, enemies, player, canvas);\r\n\r\n        this.isFiring = false;\r\n        this.isReloading = false;\r\n        this.ammo = 50;\r\n        this.reloadAmmo = 600;\r\n     \r\n\r\n\r\n        this.fireRate = 100;\r\n        this.canFire = true;\r\n        this.currentFireRate = 0;\r\n        this.toggleAutomatic = true;\r\n\r\n        this.damage = 15;\r\n        \r\n        this.loadBulletholes();\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n    \r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'm60.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n    \r\n       \r\n        const transformNode = new TransformNode('glb');\r\n        \r\n      \r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach( (animationGroup) => {\r\n                animationGroup.stop();\r\n            \r\n                \r\n                animationGroup.start(true, 0.5, 755, 850);\r\n                \r\n                \r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        \r\n    \r\n        transformNode.parent = this.camera;\r\n        \r\n \r\n        transformNode.position.y -= 0.2;\r\n        transformNode.position.z += 0.5;\r\n        transformNode.position.x += 0.32;\r\n     \r\n     \r\n       \r\n        transformNode.scaling.set(1,1,1);\r\n     \r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/lmgfire1.wav\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/LMGreload.wav\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyLMG2.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        // plane.position.x= -size/2;\r\n        // plane.position.y= -size/2;\r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n\r\n       \r\n        \r\n\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1.5, 0, 21);\r\n    \r\n\r\n\r\n\r\n\r\n       \r\n        if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10);\r\n\r\n           /*  \r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n               \r\n                this.muzzleFlashParticleSystem!.emitter = this.gunMesh;\r\n            }); */\r\n            \r\n        }\r\n\r\n\r\n\r\n            \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                gun.isFiring = true;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n    \r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.5, 755, 850);\r\n\r\n            });\r\n            gun.isFiring = false; // Reset the flag\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n            gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 16, 320);\r\n    \r\n           \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                \r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readyAnimation(gun: Weapon): void {\r\n        gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 660, 754);\r\n    \r\n            \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                \r\n               \r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n    shoot(): void {\r\n        if (this.canFire && !this.isReloading) {\r\n\r\n        if (this.ammo > 0) {\r\n\r\n                this.shootSound.play();\r\n\r\n                // Create the picking ray from the center of the screen with random deviation\r\n                const deviationAngle = Math.random() * Math.PI * 2; // Random angle between 0 and 2*pi\r\n                const deviationAmount = Math.random() * 0.04; // Random deviation amount\r\n                const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n                \r\n                // Calculate the new ray direction with deviation\r\n                const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n          \r\n\r\n\r\n\r\n\r\n\r\n\r\n            // Create the picking ray from the center of the screen\r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n\r\n            ray.direction = rayDirection;\r\n    \r\n            \r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n           \r\n            if (raycastHit && raycastHit.hit) {\r\n                \r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                  \r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n                    if(enemy) {\r\n                    \r\n                    enemy!.health -= this.damage;\r\n\r\n                    //console.log(\"dead?\" , enemy!.states.DESTROYED);\r\n\r\n                    if (enemy!.health > 0) {\r\n                        // Play shot animation on the enemy\r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                       \r\n                        this.playDeathAnimation(enemy!);\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                            if(enemy) {\r\n                            const index = this.enemies.indexOf(enemy!);\r\n                            if (index !== -1) {\r\n                               \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                               \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n\r\n\r\n\r\n                          \r\n                        }\r\n\r\n\r\n                        });\r\n\r\n                        \r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n\r\n                // Dispose of the decal after 10 seconds\r\n                    setTimeout(() => {\r\n                        decal.dispose();\r\n                    }, 10000);\r\n                }\r\n                        \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n        }\r\n    }\r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(50 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n        \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"textures/bullet_hole.png\", this.scene);\r\n\r\n        \r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n \r\n      \r\n    \r\n}\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    \r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    \r\n    const texture = new Texture(\"./textures/particles/muzzle_05.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    \r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(-0.2, 0.1, 4); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(-0.2, 0.1, 4); \r\n      \r\n\r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange \r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 1; \r\n    this.muzzleFlashParticleSystem.maxSize = 1.5; \r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.emitRate = 20; \r\n\r\n   \r\n    \r\n\r\n    \r\n    \r\n\r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\ncontrolFireRate() {\r\n    if (!this.canFire) {\r\n        this.currentFireRate -= this.scene.getEngine().getDeltaTime();\r\n        \r\n        if (this.currentFireRate <= 0) {\r\n            this.canFire = true;\r\n            this.currentFireRate = this.fireRate;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4 } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class Pistol extends Weapon {\r\n\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n\r\n\r\n    canFire!: boolean;\r\n    currentFireRate: number;\r\n\r\n    muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n\r\n\r\n    damage: number;\r\n    \r\n\r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        super(scene, camera, enemies, player, canvas);\r\n        this.scene.getEngine().displayLoadingUI();\r\n\r\n        this.isFiring = false;\r\n        this.isReloading = false;\r\n        this.ammo = 12;\r\n        this.reloadAmmo = 36;\r\n     \r\n\r\n\r\n        this.fireRate = 100;\r\n        this.canFire = true;\r\n        this.currentFireRate = 0;\r\n        this.toggleAutomatic = false;\r\n\r\n\r\n        this.damage = 10;\r\n        \r\n        this.loadBulletholes();\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n        //const mesh = await SceneLoader.ImportMeshAsync('', './models/', 'rifle.glb');\r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'pistol.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n    \r\n        // Create a new TransformNode to hold the gun meshes\r\n        const transformNode = new TransformNode('glb');\r\n        \r\n        // Parent each mesh in the loaded model to the TransformNode\r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach( (animationGroup) => {\r\n                animationGroup.stop();\r\n                //animationGroup.start(true, 0.1, 0, 10); // shoot\r\n                \r\n                animationGroup.start(true, 0.2, 436, 498);\r\n                \r\n\r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        \r\n        // Parent the TransformNode to the camera\r\n        transformNode.parent = this.camera;\r\n        \r\n        // Adjust the position of the gun relative to the camera\r\n        transformNode.position.y -= 0.16;\r\n        transformNode.position.z += 0.5;\r\n        transformNode.position.x += 0.32;\r\n        \r\n        // Adjust the rotation of the gun\r\n     \r\n        // Adjust the scaling of the gun\r\n        transformNode.scaling.set(0.01,0.01,0.01);\r\n        // transformNode.scaling.set(0.5, 0.5, 0.5  ); // gun\r\n\r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/pistolshoot.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/reload.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyRifle.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n\r\n        //this.scene.getEngine().hideLoadingUI();\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        // plane.position.x= -size/2;\r\n        // plane.position.y= -size/2;\r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n\r\n       \r\n        \r\n\r\n        gun.isFiring = true;\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 0, 28);\r\n    \r\n        \r\n\r\n\r\n\r\n\r\n        // Start the muzzle flash particle system when the shooting animation begins\r\n        if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10); // Adjust duration of the muzzle flash\r\n\r\n           /*  // Update the position of the particle system on each frame\r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n                // Update the position of the particle system to match the position of the gun mesh\r\n                this.muzzleFlashParticleSystem!.emitter = this.gunMesh;\r\n            }); */\r\n            \r\n        }\r\n\r\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            // Register a callback for when the animation ends\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                // Start the idle animation when the shoot animation ends\r\n                //gun.isFiring = true;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n    \r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.2, 436, 498);\r\n\r\n            });\r\n            gun.isFiring = false; // Reset the flag\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n            gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 135, 315);\r\n    \r\n            // Register a callback for when the animation ends\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                // Start the idle animation when the shoot animation ends\r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readyAnimation(gun: Weapon) {\r\n        gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            //animationGroup.start(false, 1.5, 230, 315);\r\n            animationGroup.start(false, 1, 340, 435);\r\n            // Register a callback for when the animation ends\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                // Start the idle animation when the shoot animation ends\r\n                //gun.isReloading = true;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    shoot(): void {\r\n        if (this.canFire && !this.isReloading) {\r\n\r\n        if (this.ammo > 0) {\r\n\r\n                this.shootSound.play();\r\n\r\n                        // Create the picking ray from the center of the screen with random deviation\r\n                const deviationAngle = Math.random() * Math.PI * 2; // Random angle between 0 and 2*pi\r\n                const deviationAmount = Math.random() * 0.04; // Random deviation amount\r\n                const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n                \r\n                // Calculate the new ray direction with deviation\r\n                const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n          \r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n            // Create the picking ray from the center of the screen\r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n\r\n            //ray.direction = rayDirection;\r\n    \r\n            // Perform the raycast and check for hits\r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n            // Check if the ray hit something\r\n            if (raycastHit && raycastHit.hit) {\r\n                // Check if the hit object has the \"enemy\" tag\r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                    // Get the enemy instance associated with the hit object\r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n    \r\n                    if(enemy) {\r\n                    // Reduce the enemy's HP by 10\r\n                    enemy!.health -= this.damage;\r\n\r\n                    //console.log(\"dead?\" , enemy!.states.DESTROYED);\r\n\r\n                    if (enemy!.health > 0) {\r\n                        // Play shot animation on the enemy\r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                        // Play death animation if the enemy is killed\r\n                        this.playDeathAnimation(enemy!);\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                           if(enemy) {\r\n                            const index = this.enemies.indexOf(enemy);\r\n                            if (index !== -1) {\r\n                               \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                                \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n                           \r\n                        }\r\n\r\n                        \r\n                          \r\n                  \r\n       \r\n                        });\r\n\r\n\r\n                        \r\n                       \r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n\r\n                   // Dispose of the decal after 10 seconds\r\n                   setTimeout(() => {\r\n                    decal.dispose();\r\n                }, 10000);\r\n            }\r\n    \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n        }\r\n    }\r\n    \r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(12 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n        \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n        // Load the bullet hole texture\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"textures/bullet_hole.png\", this.scene);\r\n\r\n        // Create a material with the bullet hole texture\r\n        \r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n        //this.bulletHoleMaterial.zOffset = -0.25;\r\n        /* this.splatter = new PBRMaterial(\"greenSplatter\", this.scene);\r\n        this.splatter.roughness = 1;\r\n        this.splatter.albedoTexture = new Texture(\"textures/green.png\", this.scene);\r\n        this.splatter.albedoTexture.hasAlpha = true;\r\n*/\r\n      \r\n    \r\n}\r\n\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    // Create particle system\r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    // Set particle texture\r\n    const texture = new Texture(\"./textures/particles/muzzle_05.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    // Set particle system properties\r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(-8, 7, 100); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(-8, 7, 100); \r\n  \r\n\r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange\r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 0.3; \r\n    this.muzzleFlashParticleSystem.maxSize = 0.74; \r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.emitRate = 10; \r\n\r\n   \r\n    \r\n\r\n    \r\n    \r\n    \r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\ncontrolFireRate() {\r\n    if (!this.canFire) {\r\n        this.currentFireRate -= this.scene.getEngine().getDeltaTime();\r\n        \r\n        if (this.currentFireRate <= 0) {\r\n            this.canFire = true;\r\n            this.currentFireRate = this.fireRate;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4, Quaternion } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class Minigun extends Weapon {\r\n\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n\r\n\r\n    canFire!: boolean;\r\n    currentFireRate: number;\r\n\r\n    muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n\r\n\r\n\r\n    isReadying: boolean;\r\n\r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        super(scene, camera, enemies, player, canvas);\r\n\r\n        this.isFiring = false;\r\n        this.isShootingAnimationPlaying = false;\r\n        this.isReloading = false;\r\n        this.isReadying = false;\r\n        this.ammo = 100;\r\n        this.reloadAmmo = 600;\r\n     \r\n\r\n\r\n        this.fireRate = 55;\r\n        this.canFire = true;\r\n        this.currentFireRate = 0;\r\n        this.toggleAutomatic = true;\r\n\r\n        this.damage = 17;\r\n       \r\n\r\n        this.loadBulletholes();\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n      \r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'minigun.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n    \r\n       \r\n        const transformNode = new TransformNode('glb');\r\n        \r\n        \r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach( (animationGroup) => {\r\n                animationGroup.stop();\r\n               \r\n                \r\n                animationGroup.start(true, 0.5, 14, 120);\r\n               \r\n\r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        \r\n        \r\n        transformNode.parent = this.camera;\r\n        \r\n        \r\n        transformNode.position.y -= 0.2;\r\n        transformNode.position.z += 0.5;\r\n        transformNode.position.x += 0.32;\r\n        \r\n        transformNode.rotate(Vector3.Up(), Math.PI/16);\r\n      \r\n     \r\n       \r\n        transformNode.scaling.set(1,1,1);\r\n       \r\n\r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/lmgfire1.wav\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 0.5,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/minigunreload.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyRifle.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 0,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        \r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n        if (!gun.isShootingAnimationPlaying) {\r\n            gun.isFiring = true;\r\n            gun.isShootingAnimationPlaying = true;\r\n    \r\n            gun.animationGroups.forEach((animationGroup) => {\r\n                animationGroup.stop();\r\n                animationGroup.start(false, 0.6, 4, 12);\r\n    \r\n             \r\n                animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                  \r\n                    gun.idleAnimation(gun);\r\n                    gun.isShootingAnimationPlaying = false; \r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    muzzleAnimation(gun: Weapon) {\r\n         \r\n          if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10); \r\n            \r\n        }\r\n    }\r\n\r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.5, 14, 120);\r\n                \r\n            });\r\n            gun.isFiring = false; \r\n            gun.isShootingAnimationPlaying = false;\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n\r\n            gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 121, 258);\r\n    \r\n           \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n           \r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readyAnimation(gun: Weapon): void {\r\n\r\n        gun.isReadying = true;\r\n        gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 280, 320);\r\n    \r\n\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                \r\n                gun.isReadying = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n       \r\n       \r\n    }\r\n\r\n    shoot(): void {\r\n        if (this.canFire && !this.isReloading) {\r\n\r\n        if (this.ammo > 0) {\r\n\r\n                this.shootSound.play();\r\n\r\n                       \r\n                const deviationAngle = Math.random() * Math.PI * 2;\r\n                const deviationAmount = Math.random() * 0.04; \r\n                const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n                \r\n              \r\n                const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n          \r\n\r\n\r\n\r\n\r\n\r\n\r\n          \r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n\r\n            ray.direction = rayDirection;\r\n    \r\n          \r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n         \r\n            if (raycastHit && raycastHit.hit) {\r\n              \r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                  \r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n                    if(enemy) {\r\n                  \r\n                    enemy!.health -= this.damage;\r\n\r\n                    \r\n\r\n                    if (enemy!.health > 0) {\r\n                      \r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                        // Play death animation if the enemy is killed\r\n                        this.playDeathAnimation(enemy!);\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                            if(enemy) {\r\n                            const index = this.enemies.indexOf(enemy!);\r\n                            if (index !== -1) {\r\n                             \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                               \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n\r\n\r\n\r\n                            \r\n                        }\r\n\r\n\r\n                        });\r\n\r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n\r\n                // Dispose of the decal after 10 seconds\r\n                    setTimeout(() => {\r\n                        decal.dispose();\r\n                    }, 10000);\r\n                }\r\n                        \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n        }\r\n    }\r\n    \r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(100 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n        \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n        //throw new Error(\"Enemy not found for the given mesh.\");\r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n        // Load the bullet hole texture\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"./textures/bullet_hole.png\", this.scene);\r\n\r\n        // Create a material with the bullet hole texture\r\n        \r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n\r\n        //this.bulletHoleMaterial.zOffset = -0.25;\r\n        /* this.splatter = new PBRMaterial(\"greenSplatter\", this.scene);\r\n        this.splatter.roughness = 1;\r\n        this.splatter.albedoTexture = new Texture(\"textures/green.png\", this.scene);\r\n        this.splatter.albedoTexture.hasAlpha = true;\r\n*/\r\n      \r\n    \r\n}\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    // Create particle system\r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    // Set particle texture\r\n    const texture = new Texture(\"./textures/particles/star_01.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    // Set particle system properties\r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(-0.3, -0.25, 3.2); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(-0.3, -0.25, 3.2); \r\n      \r\n    \r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange \r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 1;\r\n    this.muzzleFlashParticleSystem.maxSize = 2; \r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.emitRate = 25; // Adjust emission rate\r\n\r\n \r\n    \r\n    \r\n    this.muzzleFlashParticleSystem.minInitialRotation = 0;\r\n    this.muzzleFlashParticleSystem.maxInitialRotation = Math.PI * 2; // Full circle\r\n\r\n\r\n\r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\ncontrolFireRate() {\r\n    if (!this.canFire) {\r\n        this.currentFireRate -= this.scene.getEngine().getDeltaTime();\r\n        \r\n        if (this.currentFireRate <= 0) {\r\n            this.canFire = true;\r\n            this.currentFireRate = this.fireRate;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { Scene, Engine, SceneLoader, Vector3, HemisphericLight, FreeCamera, Sound, Mesh, AbstractMesh, TransformNode, MeshBuilder, StandardMaterial, Texture, Color3, Material, Animation, Matrix, PBRMaterial, CubeTexture, Quaternion, Ray, EasingFunction, CubicEase, PhysicsImpostor, ColorGradient, Color4, Tags, CannonJSPlugin, SceneOptimizerOptions, SceneOptimizer, HardwareScalingOptimization, ScenePerformancePriority } from \"@babylonjs/core\";\r\nimport { AdvancedDynamicTexture, TextBlock, Button, Rectangle, Control, LinearGradient } from \"@babylonjs/gui\";\r\n\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Level } from \"./Level\";\r\nimport { Weapon } from \"./Weapon\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Player } from \"./Player\";\r\n\r\nimport { AmmoPickup } from \"./AmmoPickup\";\r\n\r\nimport { FirstAidPickup } from \"./FirstAidPickup\";\r\nimport { WeaponPickups } from \"./WeaponPickups\";\r\n\r\nimport { UI } from \"./UI\";\r\nimport { Mutant } from \"./Mutant\";\r\nimport { Warrok } from \"./Warrok\";\r\n\r\n\r\n\r\nimport { M60 } from \"./M60\";\r\nimport { Pistol } from \"./Pistol\";\r\nimport { Minigun } from \"./Minigun\";\r\n\r\nimport { TorchPowerup } from \"./TorchPowerup\";\r\n\r\nexport class FirstPersonController {\r\n    scene: Scene;\r\n    engine: Engine;\r\n    weapon!: Weapon;\r\n    inventory!: Weapon[];\r\n    currentWeaponIndex!: number;\r\n    camera!: FreeCamera;\r\n    level: Level;\r\n    isJumping!: boolean;\r\n    wantToJump!: boolean;\r\n    isMoving!: boolean;\r\n    //bulletHoleMaterial!: PBRMaterial;\r\n    isSprinting: boolean;\r\n\r\n    ui: UI;\r\n\r\n    enemies: Enemy[];\r\n    player: Player;\r\n\r\n    playerBox: any;\r\n    ground: any;\r\n\r\n    //ammoBoxSound: Sound;\r\n    //firstAidSound: Sound;\r\n    outOfBreathSound: Sound;\r\n    \r\n\r\n    jumpSpeed: number;\r\n    jumpHeight: number;\r\n    jumpPeak: number;\r\n\r\n    minigun!: Minigun;\r\n    pistol!: Pistol;\r\n    rifle!: Weapon;\r\n\r\n\r\n    ammopickup: AmmoPickup;\r\n    firstaid: FirstAidPickup;\r\n    weaponPickups: WeaponPickups;\r\n    lmg: M60;\r\n    torchPowerup: TorchPowerup;\r\n\r\n    canReload!: boolean;\r\n\r\n    isPaused!: boolean;\r\n    \r\n\r\n    constructor(private canvas: HTMLCanvasElement) {\r\n\r\n        \r\n        \r\n      this.engine = new Engine(this.canvas, true);\r\n     \r\n      this.level = new Level(this.engine, this);\r\n      this.scene = this.level.scene;\r\n      //this.scene.blockMaterialDirtyMechanism = true;\r\n      \r\n\r\n      this.canReload = true;\r\n      this.isPaused = false;\r\n\r\n   /*    const optimizerOptions = new SceneOptimizerOptions(\r\n        \r\n    );\r\n\r\n    optimizerOptions.addOptimization(new HardwareScalingOptimization(0,1));\r\n    \r\n    \r\n    SceneOptimizer.OptimizeAsync(this.scene, optimizerOptions); */\r\n    \r\n      \r\n       \r\n            this.outOfBreathSound = new Sound(\r\n                \"outOfBreath\",\r\n                \"./audio/player/outofbreath.mp3\",\r\n                this.scene,\r\n                null,\r\n                {\r\n                    //spatialSound:true,\r\n                    volume: 1,\r\n                    autoplay:false\r\n                });\r\n\r\n\r\n                \r\n\r\n      this.isSprinting = false;\r\n      this.isJumping = false;\r\n      this.isMoving = false;\r\n      this.jumpSpeed = 0.1; \r\n      this.jumpHeight = 2; \r\n      this.jumpPeak = 0; \r\n \r\n      this.enemies = [];\r\n      this.inventory = [];\r\n\r\n      this.ammopickup = this.level.ammopickup;\r\n      this.firstaid = this.level.firstaid;\r\n\r\n     \r\n      this.CreateController();\r\n      \r\n      this.CreateImpostors();\r\n      this.player = new Player(this.camera, this.scene, this);\r\n   \r\n\r\n      /* this.level.startWaveSystem(); */\r\n   \r\n\r\n\r\n      this.minigun = new Minigun(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n      this.pistol = new Pistol(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n      this.rifle = new Weapon(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n      this.lmg = new M60(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n\r\n      this.lmg.preloadMesh();\r\n      this.minigun.preloadMesh();\r\n      this.rifle.preloadMesh();\r\n\r\n      this.weapon = this.pistol;\r\n\r\n      this.inventory.push(this.weapon);\r\n      \r\n\r\n \r\n\r\n\r\n     /*  this.inventory.push(new Weapon(this.scene, this.camera, this.enemies));\r\n      this.inventory.push(new Pistol(this.scene, this.camera, this.enemies));\r\n      this.inventory.push(new Minigun(this.scene, this.camera, this.enemies)); */\r\n      this.currentWeaponIndex = 0;\r\n\r\n\r\n        // Preload meshes for all weapons in the inventory\r\n        this.inventory.forEach((weapon, index) => {\r\n            if(weapon !== this.weapon) {\r\n                weapon.preloadMesh();\r\n            }\r\n        });\r\n\r\n      \r\n      \r\n       \r\n\r\n     \r\n      this.weapon.CreateG();\r\n  \r\n  \r\n      this.setupInput();\r\n      this.loadFootsteps();\r\n  \r\n\r\n      //this.loadText();\r\n\r\n      this.ui = new UI(this.player, this.weapon, this.inventory, this.currentWeaponIndex, this.level);\r\n      this.ui.unpauseButton.onPointerClickObservable.add(() => {\r\n        this.togglePause();\r\n        \r\n    });\r\n\r\n      //this.switchWeapon(this.currentWeaponIndex);\r\n\r\n/*         \r\n        this.ammopickup.CreateAmmoPickup(new Vector3(95,0,-76));\r\n\r\n        \r\n        this.firstaid.CreateFirstAidPickup(new Vector3(100,0,-86)); */\r\n\r\n\r\n      this.weaponPickups = this.level.weaponPickups;\r\n    /*   this.weaponPickups.CreateMinigunPickup(new Vector3(90,0,-75));\r\n      this.weaponPickups.CreatePistolPickup(new Vector3(100,0,-75));\r\n      this.weaponPickups.CreateRiflePickup(new Vector3(110,0,-75));\r\n      this.weaponPickups.CreateLMGPickup(new Vector3(120,0,-75)); */\r\n\r\n\r\n      this.torchPowerup = new TorchPowerup(this.scene, this.camera);\r\n\r\n      this.torchPowerup.CreateTorchPowerup(new Vector3(-30, 0, 40));\r\n\r\n      \r\n\r\n      let isShooting = false;\r\n\r\nthis.scene.onPointerDown = (evt) => {\r\n    if (!this.engine.isPointerLock && evt.button === 0) {\r\n        this.engine.enterPointerlock();\r\n        Engine.audioEngine?.unlock();\r\n    } else if (evt.button === 0 && !this.player.isDead() && !this.weapon.isReloading) {\r\n        if (this.weapon.toggleAutomatic) {\r\n            isShooting = true;\r\n            this.canReload = false;\r\n            shootLoop();\r\n        } else {\r\n            shootOnce();\r\n        }\r\n    }\r\n};\r\n\r\nthis.scene.onPointerUp = (evt) => {\r\n    if (evt.button === 0) {\r\n        isShooting = false;\r\n        this.canReload =  true;\r\n    }\r\n};\r\n\r\nlet lastShotTime = 0;\r\n\r\n\r\n\r\nconst shootOnce = () => {\r\n    if (this.weapon.ammo > 0) {\r\n        this.weapon.shoot();\r\n       \r\n\r\n        if(this.weapon === this.minigun) { \r\n            \r\n\r\n            if(this.weapon.isReadying) {\r\n                this.weapon.animationGroups.forEach(function (animationGroup) {\r\n                    animationGroup.stop();\r\n                });\r\n\r\n                this.weapon.isReadying = false;\r\n\r\n            }\r\n\r\n                this.weapon.shootAnimation(this.weapon);\r\n            \r\n            this.minigun.muzzleAnimation(this.weapon); \r\n            \r\n        }\r\n\r\n\r\n        else {\r\n            this.weapon.shootAnimation(this.weapon);\r\n        }\r\n\r\n\r\n    } else {\r\n        this.weapon.emptySound.play();\r\n    }\r\n};\r\n\r\n\r\n\r\nconst shootLoop = () => {\r\n    const currentTime = performance.now(); \r\n    if (isShooting && this.weapon.toggleAutomatic) {\r\n        if (this.weapon.ammo > 0 && currentTime - lastShotTime >= this.weapon.fireRate) {\r\n            shootOnce();\r\n            lastShotTime = currentTime;\r\n        } else if (this.weapon.ammo <= 0) {\r\n            isShooting = false;\r\n            this.weapon.emptySound.play();\r\n        }\r\n    }\r\n    requestAnimationFrame(shootLoop);\r\n};\r\n\r\n\r\nrequestAnimationFrame(shootLoop);\r\n\r\n\r\n\r\n\r\n\r\nthis.scene.onDataLoadedObservable.addOnce(() => {\r\n    \r\n    this.camera.needMoveForGravity = true;\r\n    this.engine.hideLoadingUI();\r\n    this.level.startWaveSystem();\r\n});\r\n\r\n      \r\n      \r\n    this.scene.registerBeforeRender(() => {\r\n  \r\n        for (const enemy of this.enemies) {\r\n          \r\n            enemy.move(this.player); \r\n            \r\n        }\r\n\r\n \r\n       if(this.playerBox.position.y+1 > 1.56) {\r\n        this.camera.position.y = this.playerBox.position.y+1;\r\n       }\r\n\r\n       \r\n\r\n        this.playerBox.position.z = this.camera.position.z;\r\n        this.playerBox.position.x = this.camera.position.x;\r\n\r\n        \r\n\r\n        if(this.camera.position.y <= 1.56) {\r\n            this.isJumping = false;\r\n        }\r\n\r\n        if(this.playerBox.position.y < 0) {\r\n            this.playerBox.position.y = 0.57; // try reset to fix bug\r\n        }\r\n    });\r\n\r\n\r\n    \r\n\r\n      this.engine.runRenderLoop(() => {\r\n\r\n\r\n\r\n        //this.checkMeshesInFrustum();\r\n\r\n        //this.level.checkFrustumVisibility();\r\n    \r\n   \r\n\r\n        if (this.isPaused) {\r\n            this.ui.showPauseScreen();\r\n            return; \r\n        }\r\n   \r\n        this.player.updatePosition(this.camera);\r\n\r\n          \r\n\r\n           \r\n            this.ui.updateAmmoText();\r\n            this.ui.updatePlayerHP();\r\n            this.ui.updateStaminaText();\r\n            this.ui.updatePlayerScore();\r\n            this.ui.updateWaveNumber();\r\n            this.ui.updateWaveTimer();\r\n\r\n\r\n            if(this.player.health <= 0) {\r\n                this.camera.position.y = 0.3;\r\n\r\n                this.weapon.animationGroups.forEach(function (animationGroup) {\r\n                    animationGroup.stop();\r\n                });\r\n                 \r\n                this.camera.detachControl();\r\n                this.engine.exitPointerlock();\r\n                this.ui.createDeathScreen();\r\n            }\r\n\r\n\r\n\r\n            if(this.isSprinting && this.player.stamina > 0) {\r\n                this.camera.speed = this.player.sprintSpeed;\r\n            }\r\n            if(!this.isSprinting || this.player.stamina <=0 ) {\r\n                this.camera.speed = this.player.walkSpeed;\r\n            }\r\n\r\n        \r\n         \r\n        this.scene.render();\r\n        \r\n      });\r\n  \r\n  \r\n  \r\n      \r\n    }\r\n  \r\n  \r\n  \r\n    CreateController(): void {\r\n      const camera = new FreeCamera(\"camera\", new Vector3(-35, 15, 55), this.scene);\r\n      camera.setTarget(new Vector3(0,1.5,-2));\r\n      camera.attachControl();\r\n      camera.applyGravity = true;\r\n      camera.checkCollisions = true;\r\n      camera.ellipsoid = new Vector3(1, 0.75, 1);\r\n      camera.minZ = 0;\r\n  \r\n      camera.speed = 1.2;\r\n      camera.angularSensibility = 800;\r\n      \r\n      camera.keysUp.push(90);\r\n      camera.keysUp.push(87);\r\n\r\n      camera.keysDown.push(83);\r\n\r\n      camera.keysLeft.push(81);\r\n      camera.keysLeft.push(65);\r\n\r\n      camera.keysRight.push(68);\r\n        \r\n      camera.inertia = 0.1;\r\n\r\n\r\n\r\n     \r\n\r\n  \r\n      this.camera = camera;\r\n\r\n      \r\n     \r\n      camera.onCollide = (collidedMesh) => {\r\n        switch (collidedMesh.id) {\r\n            case 'ammoBox':\r\n                this.ammopickup.pickupSound.play();\r\n                this.weapon.reloadAmmo += 120;\r\n                this.weapon.reloadWeapon();\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'firstAid':\r\n                this.firstaid.pickupSound.play();\r\n                this.player.health = this.player.maxHealth;\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'minigunPickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.minigun)) {\r\n                    this.inventory.push(this.minigun);\r\n                } else {\r\n                    this.minigun.reloadAmmo += 180;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'pistolPickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.pistol)) {\r\n                    this.inventory.push(this.pistol);\r\n                } else {\r\n                    this.pistol.reloadAmmo += 60;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'riflePickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.rifle)) {\r\n                    this.inventory.push(this.rifle);\r\n                } else {\r\n                    this.rifle.reloadAmmo += 60;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'lmgPickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.lmg)) {\r\n                    this.inventory.push(this.lmg);\r\n                } else {\r\n                    this.lmg.reloadAmmo += 120;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'torchPowerup':\r\n                this.torchPowerup.pickupSound.play();\r\n                this.rifle.damage += 4;\r\n                this.pistol.damage += 2;\r\n                this.minigun.damage += 6;\r\n                this.lmg.damage += 6;\r\n    \r\n                this.player.score += this.level.torchPowerup.scoreValue;\r\n    \r\n                if (this.player.jumpingPower < 12) {\r\n                    this.player.jumpingPower += 1;\r\n                }\r\n    \r\n                if (this.player.staminaDecayRate > 2) {\r\n                    this.player.staminaDecayRate -= 1;\r\n                }\r\n    \r\n                if (this.player.staminaRegenRate < 10) {\r\n                    this.player.staminaRegenRate += 1;\r\n                }\r\n    \r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'medalPowerup':\r\n                this.torchPowerup.pickupSound.play();\r\n                if (this.player.sprintSpeed < 7) {\r\n                    this.player.sprintSpeed += 0.25;\r\n                }\r\n    \r\n                this.player.score += this.level.medalPowerup.scoreValue;\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            default:\r\n                \r\n                break;\r\n        }\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n\r\n    \r\n      \r\n    \r\n\r\n      \r\n      }\r\n  \r\n      \r\n\r\n      \r\n     \r\n      \r\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    setupInput(): void {\r\n\r\n        const pressedKeys: { [key: string]: boolean } = {\r\n            KeyW: false,\r\n            KeyA: false,\r\n            KeyS: false,\r\n            KeyD: false,\r\n            ShiftLeft: false,\r\n            ShiftRight: false\r\n        };\r\n\r\n\r\n\r\n         \r\n         document.addEventListener('keydown', (event) => {\r\n             if (event.code === 'KeyW' || event.code === 'KeyA' || event.code === 'KeyS' || event.code === 'KeyD') {\r\n                \r\n                 this.isMoving = true;\r\n                 pressedKeys[event.code] = true;\r\n             }\r\n\r\n             if ((event.code === 'ShiftLeft' || event.code === 'ShiftRight') && this.isMoving) {\r\n                event.preventDefault();\r\n                 this.isSprinting = true;\r\n                 if(this.player.stamina > 0) {\r\n                     this.camera.speed = this.player.sprintSpeed;\r\n                 }\r\n                 else {\r\n                     this.camera.speed = this.player.walkSpeed;\r\n                 }\r\n                 this.player.decayStamina();\r\n             }\r\n\r\n\r\n              \r\n                    switch (event.code) {\r\n                        case 'Digit1':\r\n                            event.preventDefault();\r\n                            this.switchWeaponByKey(0);\r\n                            break;\r\n                        case 'Digit2':\r\n                            event.preventDefault();\r\n                            this.switchWeaponByKey(1);\r\n                            break;\r\n                        case 'Digit3':\r\n                            event.preventDefault();\r\n                            this.switchWeaponByKey(2);\r\n                            break;\r\n                        case 'Digit4':\r\n                            event.preventDefault(); // default 4 on firefox\r\n                            this.switchWeaponByKey(3);\r\n                            break;\r\n\r\n                        case 'Digit9':\r\n                            event.preventDefault();\r\n                            this.toggleGodMode();\r\n                            break;\r\n\r\n\r\n                       /*  case 'Digit8': \r\n                            event.preventDefault();\r\n                            this.togglePause();\r\n                            break; */\r\n                    }\r\n         });\r\n\r\n         \r\n         document.addEventListener('keyup', (event) => {\r\n             if (event.code === 'KeyW' || event.code === 'KeyA' || event.code === 'KeyS' || event.code === 'KeyD') {\r\n                 \r\n                 pressedKeys[event.code] = false;\r\n                 if (!pressedKeys['KeyW'] && !pressedKeys['KeyA'] && !pressedKeys['KeyS'] && !pressedKeys['KeyD']) {\r\n                     this.isMoving = false;\r\n                 }\r\n             }  \r\n\r\n             if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {\r\n                 \r\n                 this.isSprinting = false;\r\n                 this.camera.speed = this.player.walkSpeed;\r\n                 this.player.regenStamina();\r\n             }\r\n         });\r\n\r\n\r\n\r\n     window.addEventListener('keydown', (event) => {\r\n      \r\n\r\n         if (event.code === 'Space' && !this.isJumping) {         \r\n                event.preventDefault();     \r\n                 this.jump();\r\n                 this.isJumping = true;\r\n         }\r\n        \r\n         if (event.code === 'KeyR') {\r\n             if (this.weapon.reloadAmmo > 0 && !this.weapon.isReloading && this.canReload) {\r\n                 this.weapon.reloadAnimation(this.weapon);\r\n                 this.weapon.reloadWeapon();\r\n                 \r\n                 this.weapon.reloadSound.play();\r\n             }\r\n         }\r\n        \r\n        if(event.code === 'KeyH') {\r\n            console.log(\"PLAYERBOX: \", this.playerBox.position.y);\r\n           \r\n      \r\n            \r\n        }\r\n\r\n        \r\n        \r\n        });\r\n\r\n    \r\n\r\n    \r\n\r\n\r\n        window.addEventListener('wheel', (event) => {\r\n            // Check if the event target is the canvas\r\n            if (event.target === this.canvas) {\r\n                // Prevent the default scrolling behavior\r\n                event.preventDefault();\r\n        \r\n                if (event.deltaY < 0) {\r\n                    this.cycleWeapon(1);\r\n                } else if (event.deltaY > 0) {\r\n                    this.cycleWeapon(-1);\r\n                }\r\n            }\r\n        }, { passive: false }); \r\n \r\n\r\n       \r\n    }\r\n    \r\n    \r\n    jump(): void {\r\n       \r\n\r\n        if(!this.isJumping && !this.player.isDead()) {\r\n            this.playerBox.physicsImpostor.applyImpulse(new Vector3(0,this.player.jumpingPower,0), this.playerBox.getAbsolutePosition());\r\n            \r\n        }\r\n    }\r\n    \r\n\r\n\r\n    \r\n\r\n        loadFootsteps(): void {\r\n\r\n            const footstepsSound = new Sound(\r\n                \"footstepsSound\",\r\n                \"./audio/footsteps.mp3\",\r\n                this.scene,\r\n                null,\r\n                {\r\n                    volume: 1, \r\n                    loop: true \r\n                }\r\n            );\r\n        \r\n            const startFootsteps = () => {\r\n                if (!footstepsSound.isPlaying) {\r\n                    footstepsSound.play();\r\n                }\r\n            };\r\n        \r\n           \r\n            const stopFootsteps = () => {\r\n                if (footstepsSound.isPlaying) {\r\n                    footstepsSound.stop();\r\n                }\r\n            };\r\n        \r\n            \r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n                if (this.isMoving && !this.player.isDead() && !this.isJumping) {\r\n                    startFootsteps();\r\n                  \r\n                } else {\r\n                    stopFootsteps();\r\n                 \r\n                }\r\n            });\r\n\r\n\r\n           \r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        loadBreathing() {\r\n            const outOfBreath = new Sound(\r\n                \"firstAidPickup\",\r\n                \"./audio/player/outofbreath.mp3\",\r\n                this.scene,\r\n                null,\r\n                {\r\n                    spatialSound:true,\r\n                    volume: 1,\r\n                    autoplay:false\r\n                });\r\n\r\n                if(this.player.stamina == 0) {\r\n                    outOfBreath.play();\r\n                }\r\n\r\n        }\r\n\r\n\r\n    \r\n\r\n        CreateImpostors(): void {\r\n\r\n                       \r\n                this.playerBox = MeshBuilder.CreateSphere(\"playerBox\", { diameter: 1}, this.scene);\r\n                this.playerBox.position.x = this.camera.position.x; \r\n\r\n                this.playerBox.position.z = this.camera.position.z;\r\n                this.playerBox.position.y = 0.055+0.5;\r\n\r\n                this.playerBox.isVisible = false;\r\n               \r\n                this.playerBox.isPickable = false;\r\n                \r\n               \r\n                this.playerBox.physicsImpostor = new PhysicsImpostor(\r\n                    this.playerBox,\r\n                    PhysicsImpostor.SphereImpostor,\r\n                    { mass: 1, restitution: 0, friction: 0 },\r\n                    this.scene\r\n                );\r\n\r\n\r\n                 this.playerBox.physicsImpostor.registerOnPhysicsCollide(\r\n                    this.ground.physicsImpostor,\r\n                    this.isNotJumping\r\n                ); \r\n        } \r\n\r\n\r\n\r\n\r\n        isNotJumping(): void {\r\n            this.isJumping = false;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n        cycleWeapon(direction: number): void {\r\n           \r\n            if (this.inventory.length === 1) {\r\n                return;\r\n            }\r\n        \r\n         \r\n            this.currentWeaponIndex += direction;\r\n        \r\n           \r\n            if (this.currentWeaponIndex < 0) {\r\n                this.currentWeaponIndex = this.inventory.length - 1;\r\n            } else if (this.currentWeaponIndex >= this.inventory.length) {\r\n                this.currentWeaponIndex = 0;\r\n            }\r\n        \r\n           \r\n          \r\n            this.switchWeapon(this.currentWeaponIndex);\r\n        }\r\n        \r\n        switchWeapon(index: number): void {\r\n          \r\n            if (index >= 0 && index < this.inventory.length) {\r\n              \r\n                if (this.weapon && this.weapon.isMeshCreated && this.weapon.gunMesh) {\r\n                    this.weapon.gunMesh.setEnabled(false);\r\n                }\r\n                \r\n              \r\n                this.weapon = this.inventory[index];\r\n                this.weapon.readyAnimation(this.weapon);\r\n                this.weapon.readySfx();\r\n\r\n                this.ui.weapon = this.weapon;\r\n                this.ui.updateAmmoText();\r\n        \r\n               \r\n                if (!this.weapon.isMeshCreated) {\r\n                    this.weapon.CreateG(); \r\n                }\r\n        \r\n             \r\n                if (this.weapon && this.weapon.isMeshCreated && this.weapon.gunMesh) {\r\n                    this.weapon.gunMesh.setEnabled(true);\r\n                }\r\n\r\n\r\n                this.currentWeaponIndex = index;\r\n        \r\n            }\r\n        \r\n        \r\n        }\r\n        \r\n\r\n        applyShockwave() {\r\n            const originalCameraSpeed = this.camera.speed;\r\n            this.camera.speed = this.camera.speed*0.5;\r\n            setTimeout(() => {\r\n                this.camera.speed = originalCameraSpeed;\r\n                /* this.camera.speed = originalCameraSpeed; */\r\n            }, 6000);\r\n\r\n        }\r\n\r\n\r\n\r\n        switchWeaponByKey(index: number): void {\r\n            if(index === this.currentWeaponIndex) { return; }\r\n\r\n            if (index >= 0 && index < this.inventory.length /* && index !== this.currentWeaponIndex */) {\r\n                this.switchWeapon(index);\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n        toggleGodMode() {\r\n            this.player.maxHealth = 9000;\r\n            this.player.health = 9000;\r\n\r\n            this.player.staminaDecayRate = 0;\r\n            this.player.staminaRegenRate = 20;\r\n\r\n            this.player.sprintSpeed = 7;\r\n            this.player.jumpingPower = 12;\r\n\r\n            /* this.pistol.damage = 1000;\r\n            this.rifle.damage = 1000;\r\n            this.lmg.damage = 1000;\r\n            this.minigun.damage = 1000; */\r\n\r\n\r\n            this.inventory.push(this.rifle);\r\n            this.inventory.push(this.lmg);\r\n            this.inventory.push(this.minigun);\r\n\r\n            \r\n        }\r\n\r\n\r\n        togglePause(): void {\r\n            \r\n    \r\n            if (this.isPaused) {\r\n\r\n                this.ui.showPauseScreen();\r\n               \r\n                this.camera.detachControl();\r\n  \r\n                \r\n\r\n\r\n            } else {\r\n                this.ui.hidePauseScreen();\r\n               \r\n                this.camera.attachControl();\r\n                \r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n        \r\n    checkMeshesInFrustum(): void {\r\n       \r\n        this.scene.meshes.forEach((mesh) => {\r\n           \r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n\r\n}","import { FirstPersonController } from \"./FirstPersonController\";\r\n\r\n// Main menu class definition\r\nexport class MainMenu {\r\n    private canvas: HTMLCanvasElement;\r\n    private startButton!: HTMLButtonElement;\r\n  \r\n    constructor(canvas: HTMLCanvasElement) {\r\n      this.canvas = canvas;\r\n      this.createUI();\r\n      this.setBackground();\r\n    }\r\n  \r\n    private createUI() {\r\n      const startButton = document.createElement('button');\r\n      startButton.innerText = 'Jouer';\r\n      startButton.style.position = 'absolute';\r\n      startButton.style.top = '50%';\r\n      startButton.style.left = '50%';\r\n      startButton.style.transform = 'translate(-50%, -50%)';\r\n      startButton.style.padding = '10px 20px';\r\n      startButton.style.fontSize = '16px';\r\n      startButton.style.backgroundColor = '#4CAF50';\r\n      startButton.style.color = 'white';\r\n      startButton.style.border = 'none';\r\n      startButton.style.borderRadius = '5px';\r\n      startButton.style.cursor = 'pointer';\r\n      \r\n      startButton.addEventListener('click', () => {\r\n        this.startGame();\r\n      });\r\n  \r\n     \r\n      document.body.appendChild(startButton);\r\n  \r\n      this.startButton = startButton;\r\n    }\r\n  \r\n    private setBackground() {\r\n      document.body.style.backgroundImage = 'url(\"textures/olympicBackground.jpg\")';\r\n      document.body.style.backgroundSize = 'cover';\r\n      document.body.style.backgroundPosition = 'center';\r\n      document.body.style.backgroundRepeat = 'no-repeat';\r\n      document.body.style.height = '100vh'; // Ensures the background covers the entire viewport\r\n      document.body.style.margin = '0';\r\n    }\r\n  \r\n    private startGame() {\r\n      // Remove the start button\r\n      this.startButton.remove();\r\n      // Initialize FirstPersonController\r\n      new FirstPersonController(this.canvas);\r\n    }\r\n}\r\n","import { render } from \"./Savior.vue?vue&type=template&id=5f2857f2&scoped=true&ts=true\"\nimport script from \"./Savior.vue?vue&type=script&lang=ts\"\nexport * from \"./Savior.vue?vue&type=script&lang=ts\"\n\nimport \"./Savior.vue?vue&type=style&index=0&id=5f2857f2&scoped=true&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-5f2857f2\"]])\n\nexport default __exports__","import { render } from \"./App.vue?vue&type=template&id=28f57374&ts=true\"\nimport script from \"./App.vue?vue&type=script&lang=ts\"\nexport * from \"./App.vue?vue&type=script&lang=ts\"\n\nimport \"./App.vue?vue&type=style&index=0&id=28f57374&lang=css\"\n\nimport exportComponent from \"../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/GOW2024-Savior/\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t524: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkb101\"] = self[\"webpackChunkb101\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [504], function() { return __webpack_require__(6875); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["render","_ctx","_cache","$props","$setup","$data","$options","_component_Savior","_hoisted_1","_hoisted_3","ref","_hoisted_4","scene","level","this","isSpellCasting","health","name","mesh","rootMesh","isDead","appliesDot","id","Enemy","enemyCount","states","isAttacking","isReacting","generateRandomPosition","position","Promise","ImportMeshAsync","meshes","animationGroups","scaling","checkCollisions","AddTagsTo","stop","play","start","onAnimationEndObservable","addOnce","pause","console","log","DESTROYED","FOLLOWING","ATTACKING","runAnimation","idleAnimation","player","distanceFromPlayer","subtract","length","attackPlayer","aggroRange","followPlayer","randomPositionX","Math","floor","random","randomPositionZ","randPosition","direction","normalize","alpha","atan2","x","z","rotation","y","collider","moveWithCollisions","multiplyByFloats","runSpeed","attackTimer","attackInterval","attackSpeed","attackOnce","clearInterval","isPlayerInRange","max","damage","hasDot","applyDot","punchAnimation","attackSound","setInterval","setTimeout","dispose","scoreValue","volume","autoplay","createBoxCollider","rotationQuaternion","clone","death","idle","punch","run","shot","uppercut","walk","walkSpeed","registerBeforeRender","CreateBox","height","width","depth","visibility","isVisible","isPickable","remove","forEach","animationGroup","isAnyAnimationPlaying","some","isPlaying","sourceAnimationGroups","targetMesh","map","sourceGroup","newGroup","targetedAnimations","targetedAnim","newAnim","animation","addTargetedAnimation","pickupSound","glowLayer","intensity","camera","isInFrustum","transformNode","shockWaveSound","shockWaveCastSound","spatialSound","isVulnerable","startVulnerabilityTimer","spellcast","speedRatio","loadParticleSystem","startSpellcastingInterval","startAddGeneration","attachToMesh","stopWaveSystem","generateAddsInterval","firstPersonController","ui","createWinScreen","detachControl","spellParticles","applyShockwave","particleSystem","particleTexture","emitter","minEmitBox","maxEmitBox","createSphereEmitter","color1","color2","colorDead","minSize","maxSize","minLifeTime","maxLifeTime","minInitialRotation","PI","maxInitialRotation","emitRate","blendMode","BLENDMODE_ONEONE","spellInterval","spellAnimation","glowInterval","removeGlowEffect","addGlowEffect","addIncludedOnlyMesh","glowColor","number","minX","maxX","minZ","maxZ","i","randomX","randomZ","enemyTypes","Mutant","SkeletonZombie","Warrok","EnemyClass","enemy","CreateMonster","enemies","push","GENERATE_ADDS_INTERVAL","generateAdds","sphereCollider","CreateSphere","diameter","glowMaterial","emissiveColor","material","setParent","parent","engine","CreateScene","waveNumber","nextWaveTime","displayLoadingUI","CreateEnvironment","CreateImpostors","createWall","createHWall","weaponPickups","WeaponPickups","ammopickup","AmmoPickup","firstaid","FirstAidPickup","torchPowerup","TorchPowerup","medalPowerup","MedalPowerup","hemilight","light","envTex","CreateFromPrefilteredData","shadowGen","useBlurCloseExponentialShadowMap","environmentTexture","createDefaultSkybox","environmentIntensity","enablePhysics","collisionsEnabled","pbr","albedoTexture","uScale","vScale","bumpTexture","invertNormalMapX","invertNormalMapY","metallicTexture","_useAmbientOcclusionFromMetallicTextureRed","useRoughnessFromMetallicTextureGreen","useMetallnessFromMetallicTextureBlue","receiveShadows","freezeWorldMatrix","cullingStrategy","CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY","ground","CreateGround","groundMaterial","CreateAsphalt","physicsImpostor","BoxImpostor","mass","restitution","loop","inventory","rifle","CreateRiflePickup","lmg","CreateLMGPickup","minigun","CreateMinigunPickup","mutant","warrok","skeletonZombie","boss","Boss","waveIntervalId","generateEnemies","startPickupGeneration","undefined","minY","maxY","CreateAmmoPickup","CreateFirstAidPickup","CreateTorchPowerup","CreateMedalPowerup","wallWidth","wallHeight","wallDepth","wallPosition","wall","wallMaterial","diffuseColor","friction","canvas","isFiring","isReloading","isReadying","ammo","reloadAmmo","loadBulletholes","fireRate","isShootingAnimationPlaying","gunMeshChild","renderingGroupId","gunMesh","set","CreateCrosshair","shootSound","emptySound","reloadSound","readySound","createMuzzleFlashParticleSystem","isMeshCreated","size","plane","CreatePlane","texture","diffuseTexture","White","opacityTexture","transparencyMode","MATERIAL_ALPHABLEND","hasAlpha","gun","muzzleFlashParticleSystem","deviationAngle","deviationAmount","deviationVector","cos","sin","ray","getForwardRay","add","createPickingRay","clientWidth","clientHeight","raycastHit","pickWithRay","hit","MatchesQuery","pickedMesh","getEnemyFromMesh","playShotAnimation","score","playDeathAnimation","index","indexOf","splice","indexFPS","CreateDecal","pickedPoint","normal","getNormal","bulletHoleMaterial","remainingAmmo","reloadAmount","min","shotAnimation","deathAnimation","zOffset","roughness","_parentContainer","CreateG","setEnabled","maxHealth","stamina","maxStamina","jumpingPower","staminaRegenRate","staminaDecayRate","sprintSpeed","outOfBreath","duration","glowOverlay","document","createElement","body","appendChild","removeChild","damagePerSecond","dotTimer","originalWalkSpeed","originalSprintSpeed","playerBox","applyImpulse","getAbsolutePosition","isRegenerating","isDecaying","regenInterval","decayInterval","weapon","currentWeaponIndex","showDeathScreen","showWinScreen","loadText","createPauseUI","advancedTexture","CreateFullscreenUI","ammoContainer","background","cornerRadius","thickness","color","horizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","verticalAlignment","VERTICAL_ALIGNMENT_TOP","top","left","addControl","ammoTextBlock","fontFamily","fontWeight","fontSize","updateAmmoText","healthContainer","healthBlock","updatePlayerHP","staminaBar","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","updateStaminaText","scoreContainer","scoreBlock","text","textHorizontalAlignment","textVerticalAlignment","waveBlock","waveTimeBlock","pauseMenu","pauseText","unpauseButton","CreateSimpleButton","VERTICAL_ALIGNMENT_BOTTOM","toString","healthBar","healthPercentage","red","green","staminaPercentage","deathScreen","HORIZONTAL_ALIGNMENT_CENTER","VERTICAL_ALIGNMENT_CENTER","youDiedText","scoreText","restartButton","onPointerUpObservable","removeControl","location","reload","winScreen","youWonText","canFire","currentFireRate","toggleAutomatic","rayDirection","getEngine","getDeltaTime","Weapon","rotate","Up","Level","canReload","isPaused","outOfBreathSound","isSprinting","isJumping","isMoving","jumpSpeed","jumpHeight","jumpPeak","CreateController","Player","Minigun","pistol","Pistol","M60","preloadMesh","setupInput","loadFootsteps","UI","onPointerClickObservable","togglePause","isShooting","onPointerDown","evt","isPointerLock","button","shootLoop","shootOnce","enterPointerlock","audioEngine","unlock","onPointerUp","lastShotTime","shoot","shootAnimation","muzzleAnimation","currentTime","performance","now","requestAnimationFrame","onDataLoadedObservable","needMoveForGravity","hideLoadingUI","startWaveSystem","move","runRenderLoop","showPauseScreen","updatePosition","updatePlayerScore","updateWaveNumber","updateWaveTimer","exitPointerlock","createDeathScreen","speed","setTarget","attachControl","applyGravity","ellipsoid","angularSensibility","keysUp","keysDown","keysLeft","keysRight","inertia","onCollide","collidedMesh","reloadWeapon","includes","pressedKeys","KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","addEventListener","event","code","preventDefault","decayStamina","switchWeaponByKey","toggleGodMode","regenStamina","window","jump","reloadAnimation","target","deltaY","cycleWeapon","passive","footstepsSound","startFootsteps","stopFootsteps","onBeforeRenderObservable","SphereImpostor","registerOnPhysicsCollide","isNotJumping","switchWeapon","readyAnimation","readySfx","originalCameraSpeed","hidePauseScreen","createUI","setBackground","startButton","innerText","style","transform","padding","backgroundColor","border","borderRadius","cursor","startGame","backgroundImage","backgroundSize","backgroundPosition","backgroundRepeat","margin","FirstPersonController","mounted","$refs","MainMenu","__exports__","components","Savior","App","mount","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","deferred","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","key","r","d","definition","o","defineProperty","enumerable","get","g","globalThis","Function","e","obj","prop","prototype","hasOwnProperty","call","p","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","data","moreModules","runtime","chunkLoadingGlobal","self","bind","__webpack_exports__"],"sourceRoot":""}